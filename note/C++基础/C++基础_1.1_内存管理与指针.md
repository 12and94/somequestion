# C++基础：1.1 内存管理与指针

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.1 内存管理与指针` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：new和malloc的区别？delete和free的区别？

### 标准准确的说法
- `new/delete` 是 C++ 运算符，`malloc/free` 是 C 标准库函数。
- `new` = 分配内存 + 调用构造函数；`delete` = 调用析构函数 + 释放内存。
- `malloc/free` 只处理“原始字节内存”，不参与对象构造/析构。
- 失败语义不同：`new` 默认抛 `std::bad_alloc`，`malloc` 返回 `nullptr`。
- 配对必须严格：`new` 对 `delete`，`new[]` 对 `delete[]`，`malloc` 对 `free`，不能交叉混用。

```cpp
struct A {
    A() { std::cout << "ctor\n"; }
    ~A() { std::cout << "dtor\n"; }
};

A* p = new A;   // 分配 + 构造
delete p;       // 析构 + 释放

int* q = static_cast<int*>(std::malloc(sizeof(int))); // 仅分配字节
std::free(q);   // 仅释放字节
```

### 通俗易懂的理解
- `new` 更像“创建对象”，`malloc` 更像“借一块裸内存”。
- 在 C++ 里，凡是有构造/析构语义，优先考虑 RAII（容器、智能指针），不要大量裸 `new/delete`。

### 面试回答简版模板
`new/delete 管对象生命周期，malloc/free 只管字节内存；两套机制不能混用，工程里优先 RAII，手写分配时严格配对。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q1_new_malloc_delete_free`

---

## 题目：智能指针有哪些？各自的原理和区别？

### 标准准确的说法
- `std::unique_ptr<T>`：独占所有权，不可拷贝、可移动，开销最小，默认优先。
- `std::shared_ptr<T>`：共享所有权，依赖控制块里的强引用计数；强计数归零时销毁对象。
- `std::weak_ptr<T>`：弱引用，不拥有对象，不增加强计数；通过 `lock()` 临时获取 `shared_ptr`。
- `shared_ptr` 循环引用会导致对象无法释放，常用 `weak_ptr` 在环上断开一条强引用。

```cpp
auto a = std::make_shared<int>(1);
std::weak_ptr<int> w = a; // 不增加强引用计数
std::cout << a.use_count() << "\n"; // 1
a.reset();
std::cout << std::boolalpha << w.expired() << "\n"; // true
```

### 通俗易懂的理解
- `unique_ptr`：一个对象一个主人。
- `shared_ptr`：多人共同持有。
- `weak_ptr`：只观察，不算“持有者”。

### 面试回答简版模板
`默认优先 unique_ptr；确实需要共享生命周期再用 shared_ptr；断环或观察对象状态用 weak_ptr。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q2_smart_pointers`

---

## 题目：指针和引用的区别？

### 标准准确的说法
- 指针是“保存地址的对象”，可为空（`nullptr`）、可重绑定到其他地址。
- 引用是“已存在对象的别名”，定义时必须绑定对象，之后不能改绑。
- 指针访问目标需解引用（`*p` / `p->`）；引用使用形式与原对象一致。
- 接口语义上：指针常表达“可选参数/可空语义”，引用常表达“对象一定存在”。

```cpp
int a = 1, b = 2;
int* p = &a; // 可重绑定
p = &b;

int& r = a;  // 绑定后不可改绑
r = 5;       // 改的是 a 的值，不是让 r 指向别处
```

### 通俗易懂的理解
- 指针像“可变门牌号”，引用像“固定外号”。
- 设计 API 时，能不用可空语义就尽量用引用，接口更清晰。

### 面试回答简版模板
`指针能为空且能改指向，引用必须绑定且不可改绑；可选参数常用指针，必选参数优先引用。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q3_pointer_vs_reference`

---

## 题目：内存泄漏是什么？如何检测和解决？

### 标准准确的说法
- 内存泄漏是“分配的内存不再可达，程序后续无法释放”。
- 泄漏不一定立刻崩溃，但会导致长期运行内存持续增长、最终触发 OOM 或性能退化。
- 常见来源：忘记释放、异常路径提前返回、所有权不清晰、容器/回调持有导致生命周期失控。
- 检测工具：ASan/LSan、Valgrind、Visual Studio 内存分析、运行期快照对比。
- 治理核心：RAII、智能指针、清晰所有权模型（谁创建谁释放，或谁拥有谁释放）。

### 通俗易懂的理解
- 泄漏就是“内存借出去了，但再也找不到归还路径”。
- 真正难点不是 `delete` 少写一行，而是对象生命周期设计不清楚。

### 面试回答简版模板
`泄漏本质是所有权丢失：排查靠工具，治理靠 RAII 和生命周期建模，而不是靠人工到处补 delete。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q04_memory_leak`

---

## 题目：什么是野指针？如何避免？

### 标准准确的说法
- 野指针通常指“未初始化指针”或“悬空指针（dangling pointer）”等非法地址引用。
- 常见来源：
  - 指针定义后未初始化直接使用。
  - 对象释放后，旧指针继续解引用。
  - 越界写破坏了指针值。
- 风险是未定义行为：随机崩溃、数据损坏、潜在安全漏洞。
- 规避策略：初始化为 `nullptr`、释放后置空、减少裸指针、使用智能指针与边界检查工具。

### 通俗易懂的理解
- 野指针不是“空指针”，而是“看起来有地址但地址不可靠”。
- 最可怕的是它可能偶尔还能跑，让 bug 更隐蔽。

### 面试回答简版模板
`野指针来自未初始化、释放后继续用、越界破坏；预防靠初始化/置空/RAII/工具化检测。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q05_dangling_pointer`

---

## 题目：const char* 和 char* const的区别？底层const和顶层const？

### 标准准确的说法
- `const char* p`：底层 const（pointee const），表示“`*p` 只读，`p` 可改指向”。
- `char* const p`：顶层 const（top-level const），表示“`p` 本身只读，`*p` 可改”。
- `const char* const p`：既不能改指向，也不能改内容。
- 模板推导与函数重载时，顶层 const 常被忽略，底层 const 影响类型兼容与重载决议。

```cpp
const char* a = "hi"; // 可改 a 指向，不可改 *a
char buf[] = "ok";
char* const b = buf;    // 不可改 b 指向，可改 *b
b[0] = 'O';
```

### 通俗易懂的理解
- 看 `const` 约束的是“指针本体”还是“指向内容”。
- 面试时别只背语法，要能说出“这个限定会如何影响接口设计”。

### 面试回答简版模板
`const char* 限制内容不可改，char* const 限制指针不可改；顶层 const 约束对象本体，底层 const 约束所指对象。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q06_const_pointer`

---

## 题目：shared_ptr的底层实现？循环引用如何解决？

### 标准准确的说法
- `shared_ptr` 由“对象指针 + 控制块”组成，控制块含强计数、弱计数、删除器、分配器等元信息。
- 强计数归零时销毁对象；弱计数归零后控制块才释放。
- 循环引用问题：两个对象互持 `shared_ptr`，强计数彼此托住，永远不归零。
- 解决办法：在环上的至少一条边改为 `weak_ptr`。

```cpp
struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev; // 用 weak_ptr 断环
};
```

### 通俗易懂的理解
- 控制块像“登记台账”，强计数是“真实房客数”，弱计数是“观察者数”。
- 断环的本质是让引用图里至少有一条边不参与“存活计数”。

### 面试回答简版模板
`shared_ptr 依赖控制块计数管理生命周期；循环引用会让强计数无法归零，工程上用 weak_ptr 断开环。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q07_shared_ptr_cycle`

---

## 题目：内存对齐是什么？为什么要内存对齐？

### 标准准确的说法
- 对齐要求由类型决定（`alignof(T)`），对象地址需满足该约束。
- 结构体布局中，成员会按对齐规则插入 padding，整体大小通常向最大对齐单位补齐。
- 目的：提高 CPU 访存效率，减少跨边界读写代价。
- 代价：空间浪费（padding），以及跨平台布局差异带来的序列化风险。

```cpp
struct S {
    char c;   // 1
    int  i;   // 4-byte align
};
// sizeof(S) 通常不是 5，而是 8（含 padding）
```

### 通俗易懂的理解
- 对齐像“按网格摆箱子”：读取快，但会留空隙。
- 二进制协议/文件映射时，不能想当然按 `sizeof` 直接跨平台互通。

### 面试回答简版模板
`内存对齐是地址与布局规则，目的是访存效率；收益是性能，代价是 padding 与布局可移植性问题。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q08_memory_alignment`

---

## 题目：malloc的底层实现？调用了哪个系统调用？

### 标准准确的说法
- `malloc` 本身是用户态分配器入口（如 ptmalloc/jemalloc/tcmalloc），不是“每次都直接 syscall”。
- 常见后端来源：
  - 小块分配：`brk/sbrk` 扩展堆。
  - 大块分配：`mmap` 直接映射。
- 分配器内部有分桶、空闲链表、缓存与合并策略，目标是降低碎片和锁竞争。
- 因此问“调用哪个系统调用”时，正确回答是“与大小/实现相关，常见 `brk/sbrk` + `mmap` 组合”。

### 通俗易懂的理解
- `malloc` 更像“内存管家”：先在已有仓库切分，不够了再向内核申请。
- 面试官想听的不是函数名背诵，而是“分配器策略 + syscall 后端 + 权衡”。

### 面试回答简版模板
`malloc 先走用户态分配器策略，常见后端是小块走 brk/sbrk、大块走 mmap；具体取决于实现和分配规模。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q09_malloc_syscall`

---

## 题目：placement new是什么？使用场景？

### 标准准确的说法
- placement new 语法 `new(ptr) T(args...)`：只调用构造函数，不申请内存。
- 典型场景：对象池、共享内存、固定缓冲区原地构造。
- 使用注意：
  - 需要手动调用析构函数。
  - 底层内存释放方式与原始分配方式匹配。
  - 对齐必须满足 `T` 的要求。

```cpp
alignas(int) unsigned char buf[sizeof(int)];
int* p = new (buf) int(42); // 原地构造
p->~int();                  // 手动析构
```

### 通俗易懂的理解
- 你先准备“地基”（内存），placement new 只负责“在地基上建对象”。
- 它解决的是“构造位置控制”，不是“分配问题”。

### 面试回答简版模板
`placement new 只做构造不做分配，适合对象池/共享内存；使用时要手动析构并保证对齐和释放配对。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q10_placement_new`

---

## 题目：智能指针new和make_shared的区别？

### 标准准确的说法
- `shared_ptr<T>(new T)` 常见实现是两次分配：对象一次、控制块一次。
- `make_shared<T>()` 常见实现可一次分配对象+控制块，局部性更好、分配次数更少。
- 异常安全上，`make_shared` 一般更稳妥。
- 例外：需要自定义删除器、与弱引用生命周期策略特殊耦合时，可能更适合显式构造。

### 通俗易懂的理解
- `make_shared` 更像“一次打包下单”，`new + shared_ptr` 像“分开下单”。
- 默认先选 `make_shared`，再根据特殊需求回退。

### 面试回答简版模板
`通常优先 make_shared（一次分配、局部性好、异常安全好）；特殊删除策略或生命周期需求再考虑 new + shared_ptr。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q11_new_vs_make_shared`

---

## 题目：引用计数如何保证线程安全？

### 标准准确的说法
- `shared_ptr` 控制块计数增减通常是原子操作，保证计数本身并发正确。
- 这不等于“对象内容”线程安全：多个线程同时改对象成员仍需同步。
- 所以要区分：
  - 所有权计数安全（`shared_ptr` 提供）
  - 业务数据安全（你自己用锁/原子保证）

### 通俗易懂的理解
- “票数统计”是安全的，不代表“屋里家具怎么改”也是安全的。
- 很多并发 bug 就是把这两层安全混为一谈。

### 面试回答简版模板
`shared_ptr 只保证控制块计数线程安全，不保证对象内部状态线程安全；对象并发访问仍需额外同步。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q12_refcount_thread_safe`

---

## 题目：weak_ptr的作用和实现原理？

### 标准准确的说法
- `weak_ptr` 持有弱引用，不参与对象生存期管理。
- 通过 `lock()` 可尝试获取 `shared_ptr`：
  - 成功：对象仍存活
  - 失败：对象已销毁
- 典型用途：观察者模式、缓存、打破 `shared_ptr` 循环引用。

### 通俗易懂的理解
- `weak_ptr` 是“看一眼但不占房间名额”。
- 访问前先 `lock()`，是为了避免使用已释放对象。

### 面试回答简版模板
`weak_ptr 的核心是“观察而不拥有”；通过 lock 判活后再访问，常用于断环和观察者场景。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q13_weak_ptr_principle`

---

## 题目：new[]的对象怎么删除？为什么？

### 标准准确的说法
- `new[]` 必须对应 `delete[]`，因为数组元素需要逐个析构。
- 若 `new[]` 配 `delete`，析构次数不匹配，属于未定义行为。
- 底层实现通常需要额外元信息记录元素数量，`delete[]` 才知道析构多少个元素。

```cpp
struct X { ~X() { std::cout << "~X\n"; } };
X* arr = new X[3];
delete[] arr; // 正确：析构3次
```

### 通俗易懂的理解
- 单对象删除是“收一个”，数组删除是“按数量逐个收”。
- 这题本质是“生命周期数量必须匹配”。

### 面试回答简版模板
`new 对 delete，new[] 对 delete[]；数组释放要保证每个元素都走析构，不能混用。`

### 对应示例
- `case/cpp_basics/memory_and_pointer/q14_new_array_delete`
