# C++基础：1.6 关键字与语法

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.6 关键字与语法` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：const的用法？const函数修饰的是什么？

### 标准准确的说法
- `const` 可以修饰：对象、指针、引用、成员函数返回类型等。
- 指针场景常见两种：
- `const T* p`：不能通过 `p` 改 `T`。
- `T* const p`：`p` 本身不可改指向，但可改所指对象。
- 成员函数后缀 `const` 修饰隐式参数 `this` 的类型：
- 在 `const` 成员函数里，`this` 类型近似 `const Class*`。
- 不能修改对象的非 `mutable` 成员（除非通过 `const_cast` 做未定义风险操作）。
- 面试中常补充“逻辑常量性”：`mutable` 可用于缓存等不影响对外语义的字段。

```cpp
class Counter {
public:
    int value() const { return val_; } // 承诺不改逻辑状态
private:
    int val_ = 0;
};
```

### 通俗易懂的理解
- `const` 本质是“修改权限控制”：到底是指针不能改、数据不能改，还是成员函数不许改对象状态。

### 面试回答简版模板
`const 要回答“约束谁不能改”；成员函数后的 const 约束 this 指向对象的可修改性，是接口契约的一部分。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q01_const_usage`

---

## 题目：static关键字的作用？

### 标准准确的说法
- `static` 在不同位置语义不同：
- 函数内局部变量：静态存储期，生命周期贯穿程序；只初始化一次。
- 类内静态成员：属于类而非对象，所有实例共享。
- 命名空间/文件作用域：内部链接（仅当前翻译单元可见）。
- C++11 起函数内静态局部初始化要求线程安全（一次性初始化）。

```cpp
int next_id() {
    static int id = 0; // 仅首次初始化
    return ++id;
}
```

### 通俗易懂的理解
- `static` 常见两件事：延长“活多久”，限制“谁看得见”。

### 面试回答简版模板
`static 的语义要分场景讲：局部变量改生命周期，类内成员改归属，文件作用域改链接可见性。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q02_static_keyword`

---

## 题目：inline函数的优缺点？和宏的区别？

### 标准准确的说法
- `inline` 的语言层核心价值：允许函数在多个翻译单元重复定义而不违反 ODR（前提定义一致）。
- 是否真正内联由编译器决定，`inline` 不是强制性能指令。
- 优点：
- 头文件定义方便。
- 小函数可能减少调用开销。
- 相比宏更安全（类型检查、作用域、调试友好）。
- 风险：
- 过度内联可能增大代码体积，反而影响指令缓存。
- 宏是预处理文本替换，无类型检查，易引入副作用。

```cpp
inline int square(int x) { return x * x; }
#define SQUARE(x) ((x) * (x))
```

### 通俗易懂的理解
- `inline` 是“正规函数的可内联许可”；宏是“字符串替换”，简单但粗糙。

### 面试回答简版模板
`inline 不等于一定内联，真正价值是语义安全和头文件复用；宏仅做文本替换，类型与副作用风险更高。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q03_inline_vs_macro`

---

## 题目：四种类型转换(static_cast等)的区别和使用场景？

### 标准准确的说法
- `static_cast`：
- 编译期可检查的常规转换（数值类型、上行转换、void* 回转等）。
- `dynamic_cast`：
- 运行时类型检查，主要用于多态层次的安全下行转换。
- 失败时指针返回 `nullptr`，引用抛异常。
- `const_cast`：
- 添加/移除 `const`/`volatile` 限定。
- 若对原本 truly const 对象去 const 后写入，行为未定义。
- `reinterpret_cast`：
- 低级位模式重解释，类型安全最弱，仅在底层系统场景谨慎使用。
- 工程建议：最小权限原则，优先 `static_cast`，最后才考虑 `reinterpret_cast`。

### 通俗易懂的理解
- 这四个 cast 像四把工具：从“相对安全”到“高风险底层操作”。

### 面试回答简版模板
`优先 static_cast；多态下转用 dynamic_cast；const_cast 只改限定符；reinterpret_cast 风险最高，只在底层必要场景使用。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q04_four_casts`

---

## 题目：lambda表达式的语法和使用？

### 标准准确的说法
- 基本语法：`[capture](params) -> ret { body }`。
- 捕获方式：
- 按值 `[=]`、按引用 `[&]`。
- 显式捕获 `[x, &y]`。
- `this` 捕获、`*this` 捕获（C++17）。
- lambda 本质是匿名函数对象（闭包类型），可带状态。
- 常见用途：标准算法回调、局部策略、异步任务提交。
- 风险点：按引用捕获超出生命周期导致悬垂引用。

```cpp
int bias = 3;
auto f = [bias](int x) { return x + bias; };
```

### 通俗易懂的理解
- lambda 就是“写在现场的小对象函数”，可顺手捕获周围变量。

### 面试回答简版模板
`lambda 要讲三件事：语法骨架、捕获语义、生命周期风险；工程里常用于算法和回调。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q05_lambda_syntax`

---

## 题目：final和override关键字的作用？

### 标准准确的说法
- `override`：显式声明“我要重写基类虚函数”，签名不匹配会编译报错。
- `final`：
- 修饰虚函数：禁止后续派生类继续重写。
- 修饰类：禁止继续继承。
- 作用是把接口演进中的错误尽量前移到编译期。

```cpp
struct Base { virtual void run(); };
struct D1 : Base {
    void run() override;
};
struct D2 final : D1 {};
```

### 通俗易懂的理解
- `override` 防“写错没报错”，`final` 防“别人再往下乱扩展”。

### 面试回答简版模板
`override 用于重写校验，final 用于封口扩展边界；两者本质是提高可维护性和重构安全性。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q06_final_override`

---

## 题目：extern关键字的作用？

### 标准准确的说法
- `extern` 用于声明“符号定义在别处”。
- `extern int g;` 是声明，不是定义；真正定义通常在某个 `.cpp`：`int g = 0;`。
- 对函数而言，普通函数默认外部链接（不写 `static` 时）。
- `extern "C"` 用于指定 C 链接约定，常用于 C/C++ 混编以避免名字改编不兼容。

```cpp
// a.h
extern int g_count;

// a.cpp
int g_count = 0;
```

### 通俗易懂的理解
- `extern` 就是“先告诉编译器：这个名字别处会给你定义”。

### 面试回答简版模板
`extern 主要用于跨文件声明符号；变量声明与定义要分清，C/C++ 混编时常配合 extern "C"。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q07_extern_keyword`

---

## 题目：volatile关键字的作用？

### 标准准确的说法
- `volatile` 告诉编译器：该对象可能在程序控制流之外被改变，禁止某些读写优化（如缓存寄存器值）。
- 常见场景：内存映射寄存器、信号处理共享变量、硬件轮询。
- `volatile` 不是线程同步原语：
- 不保证原子性。
- 不保证多线程内存可见性顺序语义（应使用 `std::atomic` 与内存序）。

### 通俗易懂的理解
- `volatile` 只解决“编译器别自作主张省略读写”，不解决“线程安全”。

### 面试回答简版模板
`volatile 用于抑制特定优化，应对外部可变源；它不等于原子操作，也不能替代互斥锁或 atomic。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q08_volatile_keyword`

---

## 题目：force inline是否一定内联？

### 标准准确的说法
- 类似 `__forceinline`（MSVC）或编译器属性只是“强烈建议”，不是标准层绝对保证。
- 编译器可能因调试选项、函数过大、递归、目标架构限制等拒绝内联。
- 是否内联应通过编译器优化报告、反汇编或性能剖析验证，而不是凭关键字假设。

### 通俗易懂的理解
- `force inline` 像“尽量插队”的请求，不是“必须插队”的法律。

### 面试回答简版模板
`force inline 不是 100% 保证，最终由编译器和优化上下文决定；要用工具验证效果。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q09_force_inline_guarantee`

---

## 题目：模板函数和普通函数编译上的区别？

### 标准准确的说法
- 普通函数在编译阶段直接生成具体符号。
- 模板函数是“蓝图”，只有在实例化点（被具体类型使用）才生成代码。
- 模板定义通常放头文件，避免链接阶段找不到实例定义。
- 模板可能导致代码膨胀（多个类型实例化多份），但也带来零开销抽象能力。

```cpp
template<class T>
T add(T a, T b) { return a + b; }

int x = add(1, 2);       // 生成 add<int>
double y = add(1.0, 2.0); // 生成 add<double>
```

### 通俗易懂的理解
- 普通函数是“成品”，模板函数是“模具”，用到什么类型才现场浇筑什么成品。

### 面试回答简版模板
`模板函数按需实例化，普通函数直接编译产物；模板常放头文件以避免链接缺失，并可能引发代码膨胀。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q10_template_vs_normal_compile`

---

## 题目：RAII是什么？

### 标准准确的说法
- RAII（Resource Acquisition Is Initialization）：把资源生命周期绑定到对象生命周期。
- 对象构造时获取资源，析构时释放资源，借助栈展开保证异常路径也能正确清理。
- 典型载体：`std::unique_ptr`、`std::lock_guard`、`std::fstream`。
- RAII 是现代 C++ 资源管理基石，可显著减少泄漏和异常路径清理错误。

```cpp
void safe() {
    std::lock_guard<std::mutex> lk(mtx); // 构造加锁
    // ...
} // 作用域结束自动解锁
```

### 通俗易懂的理解
- RAII 就是“资源跟对象走”：进作用域拿资源，出作用域自动还资源。

### 面试回答简版模板
`RAII 通过对象生命周期自动管理资源，尤其在异常场景下比手写 release 更可靠，是现代 C++ 的核心习惯。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q11_raii`
