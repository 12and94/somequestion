# C++基础：1.6 关键字与语法

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.6 关键字与语法` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：const的用法？const函数修饰的是什么？

### 标准准确的说法
- `const` 的核心是“只读约束”，但要明确它约束的是“谁”。

1. 修饰普通对象
- `const int x = 10;`：`x` 不可再赋值。
- 这是“对象只读”语义。

2. 修饰引用
- `const T&`：通过该引用不能修改对象。
- 常见于函数参数，避免拷贝且防止误改：
  - `void f(const std::string& s);`

3. 修饰指针（高频易混）
- `const T* p` 或 `T const* p`：
  - “指向 const 的指针”；
  - 可改 `p` 指向，但不能通过 `p` 改对象。
- `T* const p`：
  - “const 指针”；
  - `p` 本身不可改指向，但可改所指对象。
- `const T* const p`：
  - 指针和对象都不可通过它修改。

4. 顶层 const 与底层 const（面试加分点）
- 顶层 const（top-level const）：
  - 约束对象本身（如 `int const x`、`T* const p` 中的指针本身）。
- 底层 const（low-level const）：
  - 约束通过间接访问到的对象（如 `const T*` 的 `T`）。
- 类型推导差异：
  - `auto` 推导通常会丢掉顶层 const；
  - 底层 const 会保留在指针/引用层级中。

```cpp
const int x = 1;
auto a = x;        // a: int（顶层 const 被忽略）
const auto b = x;  // b: const int

const int* p = &x;
auto q = p;        // q: const int*（底层 const 保留）
```

5. `const` 成员函数修饰的到底是什么
- 语法：`Ret f(...) const;`
- 它修饰的是隐式参数 `this` 的类型：
  - 在非 `const` 成员函数中，`this` 近似 `Class* const`；
  - 在 `const` 成员函数中，`this` 近似 `const Class* const`。
- 结果：
  - 不能修改对象的非 `mutable` 成员；
  - 只能调用同类的 `const` 成员函数（除非做显式转换）。

6. `const` 成员函数重载
- 可按对象常量性重载同名函数，这是标准容器常见写法：

```cpp
class Buffer {
public:
    int& at(std::size_t i) { return data_[i]; }              // 可写版本
    const int& at(std::size_t i) const { return data_[i]; }  // 只读版本
private:
    std::vector<int> data_{1, 2, 3};
};
```

- 当对象是 `const Buffer` 时，只能调 `const` 版本。

7. `mutable` 与“逻辑常量性”
- `const` 函数强调“对外可观察语义不变”，不是“物理比特绝对不变”。
- `mutable` 允许在 `const` 函数中修改某些“不影响对外语义”的字段（如缓存、访问计数、惰性初始化标记）。

```cpp
class Counter {
public:
    int value() const {
        ++access_times_;       // 合法：mutable 字段
        return val_;
    }
private:
    int val_ = 0;
    mutable int access_times_ = 0; // 不改变业务语义
};
```

8. `const_cast` 的边界（必须讲清）
- `const_cast` 只能改“类型限定符表面”，不能改变对象本质是否真 const。
- 若对象本体就是 `const`，去 const 后写入是未定义行为（UB）。
- 只有当对象本体原本非 const、只是经由 `const` 视图访问时，去 const 并写入才可能合法。

9. 返回值上的 const（常见误区）
- 返回“按值对象”时写 `const T` 通常意义很小，且可能妨碍移动语义，不推荐。
- 返回引用/指针时 `const` 很有意义：
  - `const T& get() const;`
  - `const T* data() const;`

10. `const` 与 `constexpr` 的区别（延伸追问）
- `const`：只读约束，未必是编译期常量。
- `constexpr`：要求可在编译期求值（满足条件时）。
- 例如局部 `const int n = runtime();` 不是编译期常量；`constexpr int m = 5;` 是。

### 通俗易懂的理解
- 把 `const` 理解成“权限系统”最不容易错：
  - 有的 `const` 限制“你手里的遥控器不能换频道”（`T* const`）；
  - 有的限制“你不能改电视内容”（`const T*`）；
  - 成员函数后的 `const` 限制“这个方法承诺不改对象主状态”。
- `const` 成员函数修饰的不是返回值，而是 `this` 这条隐式指针。

### 面试回答简版模板
`const 的本质是只读约束，关键是说清“约束谁”。在指针里要区分 const T*、T* const、const T* const；在成员函数里，后缀 const 修饰的是 this（近似 const Class* const），所以不能改非 mutable 成员，也只能调用 const 成员函数。工程上再补一句：const_cast 不能安全修改 truly const 对象，返回值按值 const 通常不推荐，常见只读接口用 const 引用/指针返回。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q01_const_usage`

---

## 题目：static关键字的作用？

### 标准准确的说法
- `static` 不是单一语义，它在不同位置主要影响三件事：
  1. 存储期（对象活多久）
  2. 链接属性（名字在几个翻译单元可见）
  3. 归属关系（属于对象还是属于类）

1. 函数内 `static` 局部变量（最常考）
- 语义：
  - 作用域仍是函数内部；
  - 但存储期变为“静态存储期”，生命周期贯穿程序运行期；
  - 只初始化一次，后续调用复用同一份对象。
- 初始化时机：
  - 不是程序启动就一定初始化，而是“第一次执行到该定义语句时”初始化（懒初始化）。
- 线程安全：
  - C++11 起保证函数局部静态初始化是线程安全的一次性初始化。
- 析构时机：
  - 程序结束阶段析构（对静态对象有顺序问题，见后述初始化顺序陷阱）。

```cpp
int next_id() {
    static int id = 0; // 第一次进入 next_id 时初始化一次
    return ++id;
}
```

2. 类内 `static` 数据成员
- 语义：
  - 属于“类本身”，不属于某个对象；
  - 所有对象共享同一份静态成员。
- 定义规则（高频追问）：
  - 类内声明，类外定义（传统写法）：
    - `struct A { static int cnt; };`
    - `int A::cnt = 0;`
  - C++17 可用 `inline static` 直接在类内定义，避免单独 `.cpp` 定义。
- 模板类注意点：
  - 每个模板实参特化有自己独立的一份静态成员。

```cpp
struct A {
    static int cnt; // 声明
};
int A::cnt = 0;     // 定义

struct B {
    inline static int cnt = 0; // C++17：类内定义
};
```

3. 类内 `static` 成员函数
- 语义：
  - 通过类名即可调用，不需要对象实例；
  - 没有 `this` 指针。
- 直接后果：
  - 不能声明为 `const` 成员函数（`const` 修饰的是 `this`，但 static 无 `this`）；
  - 不能是虚函数（virtual 依赖对象动态分发，也需要对象语义）。

```cpp
struct Tool {
    static int add(int a, int b) { return a + b; }
};
// int x = Tool::add(1, 2);
```

4. 命名空间/文件作用域 `static`（内部链接）
- 在全局/命名空间作用域写 `static`，表示内部链接：
  - 该符号仅当前翻译单元可见（当前 `.cpp`）。
- 作用：
  - 避免与其他翻译单元同名符号冲突；
  - 限制可见性，减少链接污染。
- C++ 中常见替代写法是匿名命名空间，效果相近（更现代风格）。

```cpp
// a.cpp
static int g_local_only = 0; // 仅 a.cpp 可见
```

5. 与 `thread_local` 区分（容易混）
- `static`：通常是“进程内一份共享状态”。
- `thread_local`：每个线程一份独立实例。
- 如果你要“线程私有计数器”，应考虑 `thread_local` 而不是 `static`。

6. 常见陷阱：静态初始化/析构顺序问题
- 跨翻译单元的静态对象初始化顺序不受你直觉控制（static initialization order fiasco）。
- 一个静态对象在构造中依赖另一个翻译单元静态对象，可能踩“未初始化先使用”。
- 常见规避方式：
  - 用“函数局部静态”延迟初始化（construct on first use）；
  - 或显式控制初始化顺序（依赖注入/启动阶段显式 init）。

```cpp
class Logger {
public:
    static Logger& instance() {
        static Logger inst; // 局部静态：首次调用时初始化
        return inst;
    }
};
```

### 通俗易懂的理解
- `static` 最好记成三句话：
  - 放在函数里：变量“活到程序结束”，且只初始化一次。
  - 放在类里：成员“归类不归对象”，大家共享一份。
  - 放在文件作用域：名字“只在本文件可见”。
- 另外再记一个工程经验：
  - 跨文件静态对象初始化顺序不可靠，优先用“函数局部 static”做懒初始化。

### 面试回答简版模板
`static 必须分位置回答：函数局部 static 改存储期（首次执行初始化一次，生命周期到进程结束，C++11 起初始化线程安全）；类内 static 成员归类不归对象，所有实例共享；文件作用域 static 改为内部链接，仅当前翻译单元可见。再补一个工程点：跨翻译单元静态初始化顺序有风险，常用函数局部 static 规避。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q02_static_keyword`

---

## 题目：inline函数的优缺点？和宏的区别？

### 标准准确的说法
- `inline` 的语言层核心价值：允许函数在多个翻译单元重复定义而不违反 ODR（前提定义一致）。
- 是否真正内联由编译器决定，`inline` 不是强制性能指令。
- 优点：
- 头文件定义方便。
- 小函数可能减少调用开销。
- 相比宏更安全（类型检查、作用域、调试友好）。
- 风险：
- 过度内联可能增大代码体积，反而影响指令缓存。
- 宏是预处理文本替换，无类型检查，易引入副作用。

```cpp
inline int square(int x) { return x * x; }
#define SQUARE(x) ((x) * (x))
```

### 通俗易懂的理解
- `inline` 是“正规函数的可内联许可”；宏是“字符串替换”，简单但粗糙。

### 面试回答简版模板
`inline 不等于一定内联，真正价值是语义安全和头文件复用；宏仅做文本替换，类型与副作用风险更高。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q03_inline_vs_macro`

---

## 题目：四种类型转换(static_cast等)的区别和使用场景？

### 标准准确的说法
- 这四种 cast 是 C++ 把“不同风险等级的转换”显式分离的机制，核心是可读性和安全边界。

1. `static_cast`（常规、编译期可验证转换）
- 能做什么：
  - 数值类型转换（`int -> double`、`double -> int`）。
  - 类层次中的上行转换（`Derived* -> Base*`）。
  - 某些明确可行的下行转换（`Base* -> Derived*`，但不做运行时检查）。
  - `void*` 与原类型指针之间回转（前提是地址确实指向该类型对象）。
  - 枚举与整数之间的显式转换。
- 不能做什么：
  - 不能移除 `const/volatile`（这属于 `const_cast`）。
  - 不能对不相关类型做任意位解释（那是 `reinterpret_cast` 范畴）。
- 风险点：
  - 下行转换若对象实际不是目标派生类型，后续使用会产生未定义行为。
- 典型场景：
  - 算术转换、容器索引类型转换、明确的接口层类型适配。

2. `dynamic_cast`（多态层次运行时检查）
- 前提条件：
  - 参与转换的基类必须是多态类型（至少有一个虚函数）。
- 能做什么：
  - 安全下行转换（`Base* -> Derived*`）。
  - 侧向转换（同一继承体系中的 cross-cast）。
- 失败行为：
  - 指针版本失败返回 `nullptr`。
  - 引用版本失败抛 `std::bad_cast`。
- 代价与特点：
  - 依赖 RTTI，有运行时开销，但能避免错误下转导致的 UB。
- 典型场景：
  - 插件系统、基类接口持有多态对象，需要按运行时真实类型分流处理。

3. `const_cast`（只改限定符，不改类型本体）
- 能做什么：
  - 添加或移除 `const`/`volatile` 限定。
  - 常用于“同一实现复用”场景：非 `const` 接口复用 `const` 版本或反之（需严格保证语义正确）。
- 不能做什么：
  - 不能改变对象动态类型，不能做数值/继承层次转换。
- 关键边界：
  - 若对象本体本来是 truly const（例如定义为 `const int x`），去 const 后写入是未定义行为。
  - 只有对象本体原本可写、只是通过 `const` 视图访问时，去 const 写入才可能合法。
- 典型场景：
  - API 历史兼容、`const`/非 `const` 重载复用实现。

4. `reinterpret_cast`（底层位模式重解释，风险最高）
- 能做什么：
  - 指针与整数类型之间转换（如 `uintptr_t`）。
  - 不相关指针类型之间的重解释。
  - 某些底层 ABI/系统编程需要的地址解释。
- 不能保证什么：
  - 不保证转换后对象语义正确；
  - 不保证满足对齐要求；
  - 不绕开严格别名规则（strict aliasing）带来的 UB 风险。
- 典型高风险点：
  - 把 `A*` 硬转 `B*` 后按 `B` 访问对象；
  - 误用函数指针重解释并调用不匹配签名。
- 典型场景：
  - 底层驱动、序列化框架的受控内存视图、与硬件/协议交互的特定代码段。

工程选择顺序（面试强烈建议这样答）：
1. 先判断是否根本不需要 cast（最佳）。
2. 需要时优先 `static_cast`。
3. 多态下转优先 `dynamic_cast` 保安全。
4. 只改限定符才用 `const_cast`。
5. 只有底层必要且风险可控才用 `reinterpret_cast`。

统一示例（覆盖四种 cast）：
```cpp
#include <cstdint>
#include <iostream>
#include <typeinfo>

struct Base { virtual ~Base() = default; };
struct Derived : Base { void run() { std::cout << "Derived\n"; } };

int main() {
    // 1) static_cast：常规数值转换
    double d = 3.14;
    int i = static_cast<int>(d); // i = 3

    // 2) dynamic_cast：多态下转安全检查
    Base* pb = new Derived;
    if (auto pd = dynamic_cast<Derived*>(pb)) {
        pd->run(); // 安全
    }

    // 3) const_cast：仅改限定符
    int x = 42;
    const int* pc = &x;               // 只是 const 视图
    int* pm = const_cast<int*>(pc);   // 合法去 const 视图
    *pm = 7;                          // x 变为 7（对象本体本来可写）

    // 4) reinterpret_cast：底层地址重解释（示例仅展示，不建议滥用）
    std::uintptr_t addr = reinterpret_cast<std::uintptr_t>(pb);
    Base* pb2 = reinterpret_cast<Base*>(addr); // 依赖平台与ABI
    (void)pb2;

    delete pb;
}
```

### 通俗易懂的理解
- 可以把四个 cast 当成四档风险工具：
  - `static_cast`：常规扳手，日常最多用。
  - `dynamic_cast`：带保险的扳手，专门处理多态下转。
  - `const_cast`：只改“只读标签”，不改对象本体类型。
  - `reinterpret_cast`：电焊枪，能干底层活但最容易出事故。
- 面试中不仅要说“能干什么”，还要说“不能保证什么”和“会在哪些条件下 UB”。

### 面试回答简版模板
`四种 cast 的边界要分清：static_cast 做常规显式转换但不做 RTTI 校验；dynamic_cast 只用于多态体系运行时安全下转，失败指针为 nullptr、引用抛 bad_cast；const_cast 只改 cv 限定，写 truly const 对象是 UB；reinterpret_cast 是底层位重解释，风险最高，仅在底层必要场景使用。工程上遵循最小权限：能不用 cast 就不用，能 static 就不 reinterpret。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q04_four_casts`

---

## 题目：lambda表达式的语法和使用？

### 标准准确的说法
- Lambda 是“匿名函数对象（closure object）”语法糖，本质是编译器生成的闭包类型及其 `operator()`。

1. 语法骨架（从简到全）
- 常见骨架：
  - `[capture](params) -> ret { body }`
- 更完整的理解（并非每项都必须写）：
  - `[capture] (params) mutable constexpr noexcept -> ret { body }`
  - C++20 还可写显式模板参数：`[]<class T>(T x) { ... }`

2. 捕获（capture）语义是重点
- 默认捕获：
  - `[=]`：按值捕获外部变量（拷贝一份到闭包对象）。
  - `[&]`：按引用捕获外部变量（闭包里持有引用）。
- 显式捕获：
  - `[x, &y]`：`x` 按值，`y` 按引用。
  - `[=, &y]`：默认按值，但 `y` 特别按引用。
  - `[&, x]`：默认按引用，但 `x` 特别按值。
- `this` 相关：
  - `[this]`：捕获 `this` 指针（不是复制整个对象）。
  - `[*this]`（C++17）：按值捕获当前对象副本，常用于异步安全快照。
- 初始化捕获（C++14）：
  - `[p = std::move(up)]`：把表达式结果初始化到闭包成员，常用于移动独占资源。

```cpp
int x = 1, y = 2;
auto a = [=]() { return x + y; };      // 默认按值
auto b = [&]() { x += 1; return x; };  // 默认按引用
auto c = [x, &y]() { y += x; };        // 混合捕获
```

3. `mutable`：按值捕获默认只读，`mutable` 才能改“副本”
- 默认情况下，lambda 的 `operator()` 是 `const`，按值捕获成员在函数体中视为只读。
- `mutable` 允许修改“按值捕获的闭包副本”，不会改外部原变量。

```cpp
int n = 10;
auto f = [n]() mutable { ++n; return n; }; // 修改的是副本
// 外部 n 仍是 10
```

4. 返回类型与参数类型
- 返回类型通常可推导；复杂分支返回类型不一致时可显式写 `-> ret`。
- 泛型 lambda（C++14）可用 `auto` 形参：
  - `[](auto x, auto y){ return x + y; }`
- C++20 可显式模板参数：
  - `[]<class T>(T x){ ... }`

```cpp
auto add = [](auto a, auto b) { return a + b; }; // 泛型 lambda
auto div = [](int a, int b) -> double { return static_cast<double>(a) / b; };
```

5. 闭包类型本质（常被追问）
- 每个 lambda 都有一个唯一匿名类型（closure type）。
- 捕获变量会变成这个类型的数据成员。
- 调用 lambda 本质是调用该类型的 `operator()`。
- 无捕获 lambda 可转换为函数指针；有捕获 lambda 通常不能。

```cpp
auto f1 = [](int x) { return x + 1; }; // 无捕获，可转函数指针
int (*pf)(int) = f1;                   // OK

int bias = 3;
auto f2 = [bias](int x) { return x + bias; }; // 有捕获
// int (*pf2)(int) = f2; // 错误：有状态闭包不能直接转函数指针
```

6. 常见使用场景
- STL 算法回调：`sort/find_if/for_each/transform`。
- 局部策略封装：把短逻辑绑定在使用点附近，提高可读性。
- 异步任务：线程池、`std::async`、事件回调。
- 资源绑定：通过初始化捕获把上下文状态一起传给回调。

7. 生命周期风险（面试必须讲）
- 引用捕获悬垂：
  - 返回或异步执行时，若引用目标已销毁，调用即 UB。
- `this` 捕获风险：
  - `[this]` 只捕获指针；对象若先析构，异步回调再用会悬空。
  - 典型改进：
    - 用 `[*this]` 复制快照（对象可拷贝时）；
    - 或捕获 `std::shared_ptr` / `std::weak_ptr` 管理生命周期。

```cpp
std::function<int()> bad_factory() {
    int x = 42;
    return [&]() { return x; }; // 错：返回后 x 生命周期结束，悬垂引用
}

std::function<int()> good_factory() {
    int x = 42;
    return [x]() { return x; }; // 对：按值捕获副本
}
```

8. 工程实践建议
- 规则 1：默认优先显式捕获（`[x, &y]`）而不是大范围 `[=]` / `[&]`。
- 规则 2：异步场景优先按值或智能指针捕获，谨慎引用捕获。
- 规则 3：lambda 过长就重构成命名函数/函数对象，提高可测试性。
- 规则 4：需要复用与类型擦除时可存入 `std::function`，但注意其开销。

### 通俗易懂的理解
- lambda 可以看成“写在现场的小函数对象”：
  - `[]` 决定它把现场哪些东西装进背包（捕获）。
  - `()` 是入参。
  - `{}` 是执行逻辑。
- 真正容易出错的不是语法，而是“背包里装的是拷贝还是引用”，以及回调执行时这些对象还在不在。

### 面试回答简版模板
`lambda 本质是匿名闭包对象，核心要讲三件事：语法骨架、捕获语义、生命周期安全。捕获上要区分按值/按引用、this 与 *this、以及初始化捕获；行为上要知道 mutable 只改副本。工程里主要用于算法回调和异步任务，最大风险是引用捕获和 this 捕获导致悬垂。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q05_lambda_syntax`

---

## 题目：final和override关键字的作用？

### 标准准确的说法
- `override`：显式声明“我要重写基类虚函数”，签名不匹配会编译报错。
- `final`：
- 修饰虚函数：禁止后续派生类继续重写。
- 修饰类：禁止继续继承。
- 作用是把接口演进中的错误尽量前移到编译期。

```cpp
struct Base { virtual void run(); };
struct D1 : Base {
    void run() override;
};
struct D2 final : D1 {};
```

### 通俗易懂的理解
- `override` 防“写错没报错”，`final` 防“别人再往下乱扩展”。

### 面试回答简版模板
`override 用于重写校验，final 用于封口扩展边界；两者本质是提高可维护性和重构安全性。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q06_final_override`

---

## 题目：extern关键字的作用？

### 标准准确的说法
- `extern` 用于声明“符号定义在别处”。
- `extern int g;` 是声明，不是定义；真正定义通常在某个 `.cpp`：`int g = 0;`。
- 对函数而言，普通函数默认外部链接（不写 `static` 时）。
- `extern "C"` 用于指定 C 链接约定，常用于 C/C++ 混编以避免名字改编不兼容。

```cpp
// a.h
extern int g_count;

// a.cpp
int g_count = 0;
```

### 通俗易懂的理解
- `extern` 就是“先告诉编译器：这个名字别处会给你定义”。

### 面试回答简版模板
`extern 主要用于跨文件声明符号；变量声明与定义要分清，C/C++ 混编时常配合 extern "C"。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q07_extern_keyword`

---

## 题目：volatile关键字的作用？

### 标准准确的说法
- `volatile` 的本质是“对编译器的约束”，不是“对 CPU/线程模型的同步承诺”。
- 它告诉编译器：
  - 对该对象的读/写是有副作用的，不能随意省略或合并；
  - 每次代码里写了读取，就要真正发起一次读取；写入同理。
- 典型动机是：对象值可能被“程序控制流之外的因素”改变，例如：
  - 硬件寄存器（MMIO）；
  - 信号处理场景（传统 C/C++ 风格）；
  - 某些非常底层的轮询寄存器代码。

`volatile` 能保证什么（要说清边界）：
1. 防止编译器把对该对象的访问优化掉（如寄存器缓存、循环外提导致不再重复读）。
2. 让源码中的访问在生成代码中“看得见”。

`volatile` 不能保证什么（高频误区）：
1. 不保证原子性：
   - `volatile int x; x++;` 仍是读-改-写三步，可能被打断。
2. 不建立线程间 happens-before 关系：
   - 不能替代 `std::atomic` 的内存序语义。
3. 不解决数据竞争：
   - 多线程下同时读写同一普通对象仍可能是 data race（UB）。

所以在现代 C++ 多线程里：
- 线程同步、可见性、顺序保证应使用 `std::atomic` / 互斥锁；
- `volatile` 不应被当作“轻量线程同步”工具。

正确场景示例（硬件寄存器轮询）：
```cpp
// 假设这个地址映射到硬件状态寄存器
volatile unsigned int* status_reg =
    reinterpret_cast<volatile unsigned int*>(0x40000000);

// 轮询直到最低位就绪
while (((*status_reg) & 0x1u) == 0u) {
    // 每次循环都必须重新读寄存器
}
```

错误示例（把 volatile 当线程同步）：
```cpp
volatile bool ready = false;
int data = 0;

// 线程 A
data = 42;
ready = true;

// 线程 B
while (!ready) {}   // 看似能看到 ready 改变
// 这里读取 data 仍不具备可靠同步语义，属于错误并发写法
```

正确替代（atomic）：
```cpp
#include <atomic>

std::atomic<bool> ready{false};
int data = 0;

// 线程 A
data = 42;
ready.store(true, std::memory_order_release);

// 线程 B
while (!ready.load(std::memory_order_acquire)) {}
// 此处读取 data 才有配套的同步保证
```

补充：`volatile` 与 `const` 可叠加
- `const volatile T`：
  - `const` 表示你不该通过该表达式改它；
  - `volatile` 表示每次访问都不能被编译器随意省略。
- 常见于“只读但可能被外部更新的状态寄存器”语义。

### 通俗易懂的理解
- 把 `volatile` 理解成“告诉编译器别偷懒”最准确：
  - 你写了读，就必须真的去读；
  - 你写了写，就必须真的去写。
- 但它不负责“线程之间如何安全通信”，那是 `atomic/锁` 的工作。

### 面试回答简版模板
`volatile 是编译器优化约束，适用于可能被外部源改变的对象（如内存映射寄存器）。它能防止访问被优化掉，但不提供原子性、线程可见性顺序或同步语义。多线程通信应使用 std::atomic 或互斥锁，不能用 volatile 代替。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q08_volatile_keyword`

---

## 题目：force inline是否一定内联？

### 标准准确的说法
- 类似 `__forceinline`（MSVC）或编译器属性只是“强烈建议”，不是标准层绝对保证。
- 编译器可能因调试选项、函数过大、递归、目标架构限制等拒绝内联。
- 是否内联应通过编译器优化报告、反汇编或性能剖析验证，而不是凭关键字假设。

### 通俗易懂的理解
- `force inline` 像“尽量插队”的请求，不是“必须插队”的法律。

### 面试回答简版模板
`force inline 不是 100% 保证，最终由编译器和优化上下文决定；要用工具验证效果。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q09_force_inline_guarantee`

---

## 题目：模板函数和普通函数编译上的区别？

### 标准准确的说法
- 普通函数在编译阶段直接生成具体符号。
- 模板函数是“蓝图”，只有在实例化点（被具体类型使用）才生成代码。
- 模板定义通常放头文件，避免链接阶段找不到实例定义。
- 模板可能导致代码膨胀（多个类型实例化多份），但也带来零开销抽象能力。

```cpp
template<class T>
T add(T a, T b) { return a + b; }

int x = add(1, 2);       // 生成 add<int>
double y = add(1.0, 2.0); // 生成 add<double>
```

### 通俗易懂的理解
- 普通函数是“成品”，模板函数是“模具”，用到什么类型才现场浇筑什么成品。

### 面试回答简版模板
`模板函数按需实例化，普通函数直接编译产物；模板常放头文件以避免链接缺失，并可能引发代码膨胀。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q10_template_vs_normal_compile`

---

## 题目：RAII是什么？

### 标准准确的说法
- RAII（Resource Acquisition Is Initialization）：把资源生命周期绑定到对象生命周期。
- 对象构造时获取资源，析构时释放资源，借助栈展开保证异常路径也能正确清理。
- 典型载体：`std::unique_ptr`、`std::lock_guard`、`std::fstream`。
- RAII 是现代 C++ 资源管理基石，可显著减少泄漏和异常路径清理错误。

```cpp
void safe() {
    std::lock_guard<std::mutex> lk(mtx); // 构造加锁
    // ...
} // 作用域结束自动解锁
```

### 通俗易懂的理解
- RAII 就是“资源跟对象走”：进作用域拿资源，出作用域自动还资源。

### 面试回答简版模板
`RAII 通过对象生命周期自动管理资源，尤其在异常场景下比手写 release 更可靠，是现代 C++ 的核心习惯。`

### 对应示例
- `case/cpp_basics/keywords_syntax/q11_raii`
