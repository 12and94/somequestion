# C++基础：1.3 类与继承

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.3 类与继承` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：类的大小怎么计算？空类大小是多少？为什么是1字节？

### 标准准确的说法
- 一个类对象的大小主要由三部分决定：
- 非静态数据成员（`int`、`double`、成员对象等）的大小。
- 对齐导致的填充字节（padding）。
- 若类含虚函数，通常会有一个虚表指针 `vptr`（实现相关，但主流编译器如此）。
- `static` 成员属于类本身，不属于对象实例，不计入 `sizeof(obj)`。
- 空类 `sizeof` 通常是 1，不是 0，原因是标准要求不同对象要有可区分地址；给 1 字节可以保证“空对象也占位”。

```cpp
class Empty {};
class A {
public:
    int x;
    static int cnt; // 不计入 sizeof(A)
};

static_assert(sizeof(Empty) == 1);
```

### 通俗易懂的理解
- `sizeof(类)` 就是在问“每个对象背着多大的包”。
- `static` 像“公用仓库”，不在对象包里。
- 空类也要能在内存里“站一个位置”，所以通常给 1 字节占位。

### 面试回答简版模板
`类对象大小看非静态成员 + 对齐填充 + 可能的 vptr；static 成员不算对象体积。空类通常是 1 字节，为了保证不同对象地址可区分。`

### 对应示例
- `case/cpp_basics/class_inheritance/q01_class_size`

---

## 题目：菱形继承是什么？如何解决？

### 标准准确的说法
- 菱形继承指：`D` 同时继承 `B`、`C`，而 `B`、`C` 又都继承同一个基类 `A`。
- 若不是虚继承，`D` 会包含两份 `A` 子对象：
- 数据重复（两份 `A::x`）。
- 成员访问二义性（`d.x` 不明确来自哪条路径）。
- 解决方案是虚继承（`virtual public A`），保证在最底层派生类中只保留一份共享 `A` 子对象。
- 使用虚继承后，对象布局和初始化规则更复杂，构造最底层类时要负责虚基类初始化。

```cpp
struct A { int x = 1; };
struct B : virtual A {};
struct C : virtual A {};
struct D : B, C {
    D() { x = 42; } // 只有一份 A::x
};
```

### 通俗易懂的理解
- 两条路都能走到祖先类，非虚继承时祖先会被“拷两份”；虚继承就是让大家共享同一份祖先。

### 面试回答简版模板
`菱形继承核心问题是重复基类子对象和访问二义性；工程上用虚继承消除重复，但要注意对象布局和构造复杂度增加。`

### 对应示例
- `case/cpp_basics/class_inheritance/q02_diamond_inheritance`

---

## 题目：结构体内存对齐规则？int, char, short的内存布局？

### 标准准确的说法
- 对齐规则（常见实现）：
- 成员偏移量通常是该成员对齐要求的整数倍。
- 结构体整体大小通常是“最大对齐要求”的整数倍。
- 因此成员之间、末尾都可能插入 padding。
- 例如：
- `struct S { char c; int i; short s; };`
- 常见布局：`c(1)` + padding(3) + `i(4)` + `s(2)` + padding(2) => 总大小 12。
- 对齐目的：减少 CPU 访存代价，避免跨边界访问惩罚（甚至某些平台异常）。

```cpp
#include <cstddef>
#include <iostream>

struct S {
    char c;
    int i;
    short s;
};

int main() {
    std::cout << sizeof(S) << '\n';
    std::cout << offsetof(S, c) << ','
              << offsetof(S, i) << ','
              << offsetof(S, s) << '\n';
}
```

### 通俗易懂的理解
- 内存像带格子的货架：类型大的货物要按更宽格子放，空出来的格子就是 padding。

### 面试回答简版模板
`结构体对齐要点是“成员按各自对齐要求摆放，整体再向最大对齐补齐”，这样访问更高效，但会产生填充空间。`

### 对应示例
- `case/cpp_basics/class_inheritance/q03_struct_alignment_layout`

---

## 题目：重载、重写、覆盖的区别？

### 标准准确的说法
- 重载（overload）：
- 同一作用域内，同名函数参数列表不同。
- 编译期决议。
- 重写/覆盖（override）：
- 发生在继承体系，基类函数为 `virtual`，派生类提供同签名函数。
- 运行期可动态分发。
- 隐藏（name hiding）：
- 派生类定义同名函数后，会遮蔽基类同名函数（即使参数不同、即使不是 virtual）。
- 需要 `using Base::func;` 才能把被隐藏重载重新引入作用域。

```cpp
struct Base {
    virtual void f(int);
    void g(double);
};
struct Derive : Base {
    void f(int) override; // 重写
    void g(int);          // 隐藏了 Base::g(double)
};
```

### 通俗易懂的理解
- 重载是“同名不同参”；重写是“子类改父类虚函数实现”；隐藏是“子类同名把父类名字挡住”。

### 面试回答简版模板
`区分三者看三个条件：是否同作用域、是否继承关系、是否 virtual 动态分发。`

### 对应示例
- `case/cpp_basics/class_inheritance/q04_overload_override_hide`

---

## 题目：类中静态变量什么时候初始化？

### 标准准确的说法
- 类静态数据成员本质是“一个全局对象”，通常需要在类外定义一次（C++17 `inline static` 可在类内定义）。
- 初始化时机分两类：
- 常量初始化（编译期可完成）通常在静态初始化阶段。
- 动态初始化在 `main` 前进行，但跨翻译单元顺序可能不确定。
- 函数内 `static` 局部对象从 C++11 起要求线程安全的“首次使用时初始化”。
- 面试常扩展点：静态初始化次序问题（static initialization order fiasco）。

```cpp
class Config {
public:
    static int g_level;
};

int Config::g_level = 3; // 类外定义
```

### 通俗易懂的理解
- 类静态成员不是“每个对象一份”，而是“全类共用一份”，初始化更像全局变量管理。

### 面试回答简版模板
`类静态成员属于类本身，通常类外定义一次；初始化要注意常量初始化、动态初始化及跨文件顺序风险。`

### 对应示例
- `case/cpp_basics/class_inheritance/q05_static_member_init`

---

## 题目：struct加static变量/虚函数后大小变化？

### 标准准确的说法
- 加 `static` 成员：通常不会改变对象大小，因为它不在对象内。
- 加虚函数：对象通常新增一个 `vptr`，对象大小可能增加一个指针大小（再叠加对齐影响）。
- 具体数值与 ABI、平台位数和编译器实现有关。

```cpp
struct S1 { int x; };               // 常见: 4
struct S2 { int x; static int y; }; // 常见: 4
struct S3 { int x; virtual void f(); }; // 常见: 16(64位下,含对齐)
```

### 通俗易懂的理解
- `static` 不进背包；`virtual` 通常会让对象背包里多一个“虚表地址”。

### 面试回答简版模板
`对象大小变化关键看是否新增非静态成员或 vptr；static 成员通常不影响 sizeof。`

### 对应示例
- `case/cpp_basics/class_inheritance/q06_struct_size_with_static_virtual`

---

## 题目：创建10个实例有几个虚函数表？

### 标准准确的说法
- 主流实现中，同一个动态类型通常共享一份 vtable。
- 每个对象有一个 `vptr` 指向该共享 vtable。
- 所以创建 10 个同类对象，通常是 10 个 `vptr`，1 份 vtable。
- 多继承/虚继承场景下可能涉及多张相关表，但“按类型共享”这一点仍成立。

### 通俗易懂的理解
- 通讯录（vtable）是一份公共资料；每个对象只保存通讯录地址（vptr）。

### 面试回答简版模板
`同类对象通常共享一张虚函数表；对象数量增加的是 vptr，不是 vtable 份数。`

### 对应示例
- `case/cpp_basics/class_inheritance/q07_how_many_vtables_for_instances`

---

## 题目：多继承可能出现什么问题？

### 标准准确的说法
- 典型问题：
- 命名冲突与调用二义性（两个基类同名成员）。
- 对象布局复杂（多个基类子对象、指针调整）。
- 菱形继承下可能出现重复公共基类。
- 类型转换更复杂：`Base1*` 到 `Base2*` 可能需要运行时偏移调整。
- 设计层面风险：继承层次过深会提升耦合与维护成本。

```cpp
struct B1 { void log(); };
struct B2 { void log(); };
struct D : B1, B2 {};

// D d; d.log(); // 二义性，需要 d.B1::log();
```

### 通俗易懂的理解
- 多继承像“同时继承两套家规”，容易冲突；技术上能做，设计上要克制。

### 面试回答简版模板
`多继承主要风险是二义性、布局复杂和可维护性下降；需要时用，但优先组合而不是滥用继承。`

### 对应示例
- `case/cpp_basics/class_inheritance/q08_multiple_inheritance_issues`
