# C++基础：1.3 类与继承

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.3 类与继承` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：类的大小怎么计算？空类大小是多少？为什么是1字节？

### 标准准确的说法
- 类对象大小的核心规则可以按“布局算法”理解：
1. 类的对齐要求 `alignof(T)` 通常等于其“非静态成员/基类子对象”中最大对齐要求（也可被 `alignas` 提高）。
2. 每个非静态成员依次放置在当前偏移后“满足自身对齐”的最小地址上。
3. 若当前位置不满足该成员对齐，会插入填充字节（padding）。
4. 全部成员放完后，`sizeof(T)` 还要向上补齐到 `alignof(T)` 的整数倍（尾部填充，tail padding）。
- 为什么需要“尾部补齐”：
  - 为了让 `T arr[N]` 数组里每个元素都满足 `alignof(T)`，`arr[i+1]` 必须天然对齐。
- 哪些东西计入 `sizeof(T)`：
  - 计入：非静态数据成员、基类子对象、对齐填充、实现附加字段（如常见 `vptr`）。
  - 不计入：`static` 数据成员（属于类级存储，不在对象内）。
- 空类为什么通常是 1 字节而不是 0：
  - 标准要求不同对象应有可区分地址；若空类大小是 0，两个空对象可能无法区分。
  - 给空类对象至少 1 字节可确保“空对象也占位”。
- 重要边界：
  - 有虚函数时，主流 ABI 下对象通常会多一个虚表指针（`vptr`），因此对象大小常增大（实现相关）。
  - 空基类优化（EBO）下，空“基类子对象”常可不额外占空间；但空“成员对象”通常仍需占位。
  - `#pragma pack`/`alignas` 会影响布局，跨平台与跨编译器时要谨慎依赖精确字节数。

常见内建类型字节数速查（面试常问）：

| 类型 | 常见字节数 | 说明 |
|---|---:|---|
| `char` / `signed char` / `unsigned char` | 1 | 标准保证 `sizeof(char)==1`（1 字节是实现定义的最小寻址单元） |
| `bool` | 1 | 常见为 1 |
| `short` | 2 | 常见为 2 |
| `int` | 4 | 常见为 4 |
| `long` | 4 或 8 | **MSVC(LLP64) 常见 4**；Linux/macOS 64 位(LP64) 常见 8 |
| `long long` | 8 | 常见为 8 |
| `float` | 4 | IEEE-754 单精度常见 |
| `double` | 8 | IEEE-754 双精度常见 |
| `long double` | 8 / 12 / 16 | 编译器/平台差异较大 |
| 指针 `T*` | 4 或 8 | 32 位进程常见 4，64 位进程常见 8 |

补充：这些是“工程常见值”，不是所有平台的绝对常量。  
若题目要求严谨，应说“以目标 ABI/编译器为准，可用 `sizeof/alignof` 实测”。

```cpp
#include <cstddef>
#include <type_traits>

class Empty {};
class A {
public:
    int x;
    static int cnt; // 不计入 sizeof(A)
};

struct S1 {
    char c;   // offset 0
    int i;    // 常见会对齐到 4，offset 常见为 4
    short s;  // 常见 offset 8
};            // 常见 sizeof(S1)=12（末尾补齐）

struct S2 {
    int i;    // offset 0
    short s;  // offset 4
    char c;   // offset 6
};            // 常见 sizeof(S2)=8（成员重排减少 padding）

static_assert(sizeof(Empty) == 1);
static_assert(offsetof(S1, i) % alignof(int) == 0);
static_assert(sizeof(S1) % alignof(S1) == 0); // 尾部补齐后的通用性质
```

可选：本机实测常见类型大小（面试前可跑一次）：

```cpp
#include <iostream>

int main() {
    std::cout << "sizeof(bool)      = " << sizeof(bool) << "\n";
    std::cout << "sizeof(char)      = " << sizeof(char) << "\n";
    std::cout << "sizeof(short)     = " << sizeof(short) << "\n";
    std::cout << "sizeof(int)       = " << sizeof(int) << "\n";
    std::cout << "sizeof(long)      = " << sizeof(long) << "\n";
    std::cout << "sizeof(long long) = " << sizeof(long long) << "\n";
    std::cout << "sizeof(float)     = " << sizeof(float) << "\n";
    std::cout << "sizeof(double)    = " << sizeof(double) << "\n";
    std::cout << "sizeof(void*)     = " << sizeof(void*) << "\n";
}
```

手算一个常见例子（`S1`）：
- `char c` 放在 offset 0，用掉 1 字节。
- 下一个 `int i` 需要 4 对齐，offset 1 不是 4 的倍数，补 3 字节到 offset 4。
- `int i` 占 4 字节到 offset 8。
- `short s` 2 对齐，offset 8 可直接放，占 2 字节到 offset 10。
- 对象总大小还需是 `alignof(S1)`（常见 4）的倍数，10 向上补齐到 12。

### 通俗易懂的理解
- `sizeof(类)` 就是在问“每个对象在内存里占几个格子”。
- 对齐像“货架有格口规格”：`int` 这种大件要放在 4 的倍数格口，不够就先塞空格（padding）。
- 不仅成员之间会有空格，末尾也可能补空格，这样数组下一个对象一开始就对齐。
- `static` 是“班级公用仓库”，不装进每个同学书包（对象）里。
- 空类即使没有数据，也要“站位”保证对象地址可区分，所以通常给 1 字节。

### 面试回答简版模板
`类大小按布局规则计算：成员按各自对齐放置，必要时插入 padding，最后再补到类对齐倍数（尾部填充，保证数组元素也对齐）。sizeof 计入非静态成员、基类子对象、padding 和实现字段（常见 vptr），不计入 static 成员。空类通常为 1 字节，用于保证不同对象地址可区分。`

### 对应示例
- `case/cpp_basics/class_inheritance/q01_class_size`

---

## 题目：菱形继承是什么？如何解决？

### 标准准确的说法
- 菱形继承定义：`D` 同时继承 `B`、`C`，且 `B`、`C` 都继承同一个基类 `A`。
- 非虚继承下为什么会出问题：
  - `D` 内部会有两份 `A` 子对象（`B::A` 和 `C::A`）。
  - 因此会出现：
    - 数据重复：同一个祖先状态存了两份。
    - 访问二义性：`d.x` 无法确定走哪条继承路径。
    - 类型转换语义复杂：经由 `B*` 和 `C*` 转成 `A*` 会得到两个不同地址。
- 虚继承为什么能解决：
  - `B` 和 `C` 不再各自“拥有一份独立 A”，而是都声明“`A` 是虚基类（shared virtual base）”。
  - 最终在最底层对象 `D` 里只保留一份共享 `A` 子对象。
  - `B`/`C` 访问 `A` 成员时，会通过实现维护的偏移/间接信息定位到这同一份 `A`。
  - 结果：`A::x` 唯一，二义性消失，状态一致。
- 构造规则（面试高频）：
  - 虚基类由“最派生类（most-derived class）”负责构造。
  - 在 `D : B, C` 场景中，构造 `D` 时 `A` 的初始化以 `D` 的初始化器为准。
  - `B`/`C` 中对 `A(...)` 的初始化器在构造 `D` 时不会生效（仅在单独构造 `B` 或 `C` 对象时生效）。
- 代价与取舍：
  - 虚继承会增加对象布局和访问路径复杂度（可能引入额外间接/偏移计算）。
  - 但它是“菱形重复基类状态”最标准、语义最清晰的解决方案。

非虚继承：问题演示（两份 `A` + 二义性）
```cpp
struct A { int x = 0; };
struct B : A {};
struct C : A {};
struct D : B, C {};

int main() {
    D d;
    // d.x = 1; // 编译错误：二义性，B::A::x 还是 C::A::x？
    d.B::x = 10;
    d.C::x = 20; // 两份独立状态
}
```

虚继承：共享一份 `A`
```cpp
#include <cassert>

struct A {
    int x;
    explicit A(int v = 0) : x(v) {}
};

struct B : virtual A {
    B() : A(1) {} // 构造 D 时，这个 A(1) 不作为最终虚基初始化来源
};

struct C : virtual A {
    C() : A(2) {} // 同上
};

struct D : B, C {
    D() : A(42), B(), C() {} // 最派生类负责虚基 A 的初始化
};

int main() {
    D d;
    assert(d.x == 42); // 只有一份 A::x

    B* pb = &d;
    C* pc = &d;
    A* pa_from_b = pb;
    A* pa_from_c = pc;
    assert(pa_from_b == pa_from_c); // 指向同一份共享 A 子对象
}
```

对象关系示意：
```text
非虚继承:
  D
  ├─ B ─ A   (一份)
  └─ C ─ A   (另一份)   -> 两份 A

虚继承:
  D
  ├─ B -\
  └─ C --+--> A (共享一份)
```

虚继承机制细化（“怎么就解决了”）：
- 关键不是“把两份 A 合并一下”这么简单，而是从对象模型上改成：
  - `B`/`C` 只记录“怎么找到虚基 A”的信息（实现可用偏移表/间接表等形式）。
  - 真正的 `A` 子对象只在最派生对象 `D` 里放一份。
- 因此不管你从 `B` 路径还是 `C` 路径访问 `A`，最终都会被调整到同一块 `A` 内存。
- 这也是为什么 `A* pa_from_b` 与 `A* pa_from_c` 在虚继承场景通常相等（指向同一虚基）。
- 代价是每次“经由中间基类去找虚基”时，编译器可能要多做一次偏移计算/间接寻址。

构造与初始化的执行逻辑（再细一层）：
1. 构造最派生对象 `D` 时，先构造虚基类 `A`（且只构造一次）。
2. 再构造非虚基类子对象（这里是 `B`、`C`）。
3. 最后执行 `D` 自己的构造函数体。
4. 因为第 1 步已确定，`B`/`C` 里写的 `A(...)` 在“构造 D 时”不会覆盖这次虚基初始化。

```cpp
#include <iostream>

struct A {
    explicit A(int v = 0) { std::cout << "A(" << v << ")\n"; }
};

struct B : virtual A {
    B() : A(1) { std::cout << "B()\n"; } // 构造 D 时，A(1) 不主导虚基初始化
};

struct C : virtual A {
    C() : A(2) { std::cout << "C()\n"; } // 构造 D 时同理
};

struct D : B, C {
    D() : A(42), B(), C() { std::cout << "D()\n"; } // 最派生类决定虚基 A
};

int main() {
    D d;
    // 常见输出顺序：A(42) -> B() -> C() -> D()
}
```

地址视角再确认“共享一份 A”：
```cpp
#include <cassert>

struct A { int x = 0; };
struct B : virtual A {};
struct C : virtual A {};
struct D : B, C {};

int main() {
    D d;
    B* pb = &d;
    C* pc = &d;
    A* pa1 = pb; // 经过 B 路径调整到虚基 A
    A* pa2 = pc; // 经过 C 路径调整到同一虚基 A
    assert(pa1 == pa2);
}
```

### 通俗易懂的理解
- 把祖先 `A` 想成“家族户口本”：
  - 非虚继承：`B` 家拿一本、`C` 家拿一本，到了 `D` 家里就有两本，内容可能不一致。
  - 虚继承：`B` 和 `C` 说“我们不各自持有户口本，只引用家里公共那一本”，所以 `D` 家里只有一本。
- “为什么就解决了”的关键不在语法词 `virtual` 本身，而在对象模型变化：
  - 从“各分支各自拥有祖先子对象”变成“所有分支共享同一个祖先子对象”。
  - 共享后自然没有重复数据，也没有 `d.x` 来自哪条路的歧义。

### 面试回答简版模板
`菱形继承在非虚场景会产生两份共同祖先子对象，导致状态重复与访问二义性。虚继承把共同祖先声明为 virtual base，使最派生对象中只保留一份共享祖先；因此二义性和重复状态消失。代价是对象布局与构造规则更复杂，且虚基由最派生类负责初始化。`

### 对应示例
- `case/cpp_basics/class_inheritance/q02_diamond_inheritance`

---

## 题目：结构体内存对齐规则？int, char, short的内存布局？

### 标准准确的说法
- 对齐规则（常见实现）：
- 成员偏移量通常是该成员对齐要求的整数倍。
- 结构体整体大小通常是“最大对齐要求”的整数倍。
- 因此成员之间、末尾都可能插入 padding。
- 例如：
- `struct S { char c; int i; short s; };`
- 常见布局：`c(1)` + padding(3) + `i(4)` + `s(2)` + padding(2) => 总大小 12。
- 对齐目的：减少 CPU 访存代价，避免跨边界访问惩罚（甚至某些平台异常）。

```cpp
#include <cstddef>
#include <iostream>

struct S {
    char c;
    int i;
    short s;
};

int main() {
    std::cout << sizeof(S) << '\n';
    std::cout << offsetof(S, c) << ','
              << offsetof(S, i) << ','
              << offsetof(S, s) << '\n';
}
```

### 通俗易懂的理解
- 内存像带格子的货架：类型大的货物要按更宽格子放，空出来的格子就是 padding。

### 面试回答简版模板
`结构体对齐要点是“成员按各自对齐要求摆放，整体再向最大对齐补齐”，这样访问更高效，但会产生填充空间。`

### 对应示例
- `case/cpp_basics/class_inheritance/q03_struct_alignment_layout`

---

## 题目：重载、重写、覆盖的区别？

### 标准准确的说法
- 重载（overload）：
- 同一作用域内，同名函数参数列表不同。
- 编译期决议。
- 重写/覆盖（override）：
- 发生在继承体系，基类函数为 `virtual`，派生类提供同签名函数。
- 运行期可动态分发。
- 隐藏（name hiding）：
- 派生类定义同名函数后，会遮蔽基类同名函数（即使参数不同、即使不是 virtual）。
- 需要 `using Base::func;` 才能把被隐藏重载重新引入作用域。

```cpp
struct Base {
    virtual void f(int);
    void g(double);
};
struct Derive : Base {
    void f(int) override; // 重写
    void g(int);          // 隐藏了 Base::g(double)
};
```

### 通俗易懂的理解
- 重载是“同名不同参”；重写是“子类改父类虚函数实现”；隐藏是“子类同名把父类名字挡住”。

### 面试回答简版模板
`区分三者看三个条件：是否同作用域、是否继承关系、是否 virtual 动态分发。`

### 对应示例
- `case/cpp_basics/class_inheritance/q04_overload_override_hide`

---

## 题目：类中静态变量什么时候初始化？

### 标准准确的说法
- 类静态数据成员有静态存储期（static storage duration），本质与命名空间作用域全局对象同类：
  - 生命周期通常从程序启动到程序结束。
  - 属于“类级唯一一份”，不属于某个对象实例。
- “声明”和“定义”要区分：
  - 类内 `static int x;` 只是声明。
  - 非 `inline` 的静态数据成员通常需要在类外提供一次定义（否则链接错误）。
  - C++17 起可用 `inline static` 在类内直接定义。
  - `static constexpr`（字面量类型）通常可在类内给出定义并作为常量使用。
- 初始化阶段建议按三步记忆（面试常考）：
1. 零初始化（zero-initialization）
  - 所有静态存储期对象先被置零。
2. 常量初始化（constant initialization）
  - 若初始化表达式是常量表达式，可在编译期完成，属于静态初始化阶段的一部分。
3. 动态初始化（dynamic initialization）
  - 其余需运行时代码执行的初始化，在 `main` 进入前完成（实现可做一定延迟策略，但不能破坏语义）。
- 顺序规则（易混）：
  - 同一翻译单元（同一 `.cpp`）内：静态对象动态初始化按定义顺序进行。
  - 不同翻译单元之间：动态初始化相对顺序通常不确定，这就是“静态初始化次序问题（fiasco）”根源。
- 函数内 `static`（local static）：
  - C++11 起要求线程安全的“首次执行到该声明时初始化”（俗称 magic static）。
  - 常用于规避跨翻译单元初始化顺序问题（Construct on First Use）。
- 可强化约束的关键字：
  - `constinit`（C++20）：强制对象必须常量初始化；若会落入动态初始化，编译报错。
  - `constexpr`：强调常量求值能力；用于常量成员和编译期场景。

基础声明/定义示例：
```cpp
struct Config {
    static int level;                  // 声明
    inline static int version = 1;     // C++17: 类内定义
    static constexpr int kMax = 64;    // 常量成员
};

int Config::level = 3; // 非 inline 静态成员的类外定义
```

不同初始化形态示例：
```cpp
int make_port();

struct S {
    static int a;           // 先零初始化，再看是否有初始化式
    static int b;           // 常量初始化（若初始化式可编译期完成）
    static int c;           // 动态初始化（调用函数）
};

int S::a;                  // 零初始化 -> 0
int S::b = 8080;           // 常量初始化
int S::c = make_port();    // 动态初始化（运行时代码）
```

跨翻译单元顺序风险示意：
```cpp
// a.cpp
int getB();
int A = getB(); // 依赖 b.cpp 的静态对象

// b.cpp
extern int A;
int B = A + 1;  // 依赖 a.cpp 的静态对象
```

上例在不同 TU 的动态初始化顺序不确定，可能出现未按预期初始化值。

规避方式（函数内 static）：
```cpp
struct Config { int level; };
Config make_config();

Config& global_config() {
    static Config cfg = make_config(); // 首次调用时初始化，线程安全（C++11+）
    return cfg;
}
```

析构顺序与 static deinitialization order fiasco（程序结束时的“反向坑”）：
- 初始化讲的是“谁先构造”，反向坑讲的是“谁后析构”。
- 基本规则：
  - 同一翻译单元内，静态对象析构顺序通常与其构造顺序相反（逆序析构）。
  - 不同翻译单元之间，析构相对顺序通常不受你显式控制。
- 风险本质：
  - 若全局/静态对象 `X` 的析构函数里访问了另一个对象 `Y`，
  - 而 `Y` 在该时刻已经先析构，`X` 析构中再访问 `Y` 就可能触发未定义行为（UAF/崩溃/日志丢失等）。

跨 TU 反向坑示意：
```cpp
// logger.cpp
#include <iostream>
struct Logger {
    ~Logger() { std::cout << "Logger destroyed\n"; }
    void write(const char* msg) { std::cout << msg << "\n"; }
};
Logger g_logger; // 全局静态对象

// service.cpp
extern Logger g_logger;
struct Service {
    ~Service() {
        // 若程序结束时 g_logger 已先析构，这里再访问可能出问题
        g_logger.write("Service shutting down");
    }
};
Service g_service; // 全局静态对象
```

工程规避思路：
1. 避免在全局/静态对象析构函数里依赖“别的全局对象仍活着”。
2. 用函数内 static + 显式生命周期管理：
   - 在受控时机手动 `shutdown()`，不要把关键收尾全压在进程退出析构阶段。
3. 对“只增不减”的进程级单例，可采用“构造一次，进程结束不析构”策略（以可控泄漏换确定性）。
4. 跨模块公共设施（日志、监控、内存器）优先由主程序统一启动/关闭顺序。

### 通俗易懂的理解
- 类静态成员可以理解成“挂在类名下的一份全局变量”。
- 它不是跟着对象出生，而是按程序级生命周期管理。
- 真正麻烦点有两个：
  - 启动时：多个 `.cpp` 文件谁先初始化不稳定。
  - 退出时：多个 `.cpp` 文件谁先析构也不稳定，可能出现“我析构时依赖对象已死”的反向坑。
- 所以工程里常用“函数内 static 首次使用再建 + 显式 shutdown 顺序”来降低风险。

### 面试回答简版模板
`类静态数据成员具有静态存储期，通常类内声明、类外定义一次（C++17 可 inline static 类内定义）。初始化经历零初始化/常量初始化/动态初始化；同一 TU 有序、跨 TU 顺序不确定，可能触发 static initialization order fiasco。程序退出时还可能出现反向的 static deinitialization order fiasco，工程上常用函数内 static 首次使用初始化 + 显式 shutdown 顺序规避。`

### 对应示例
- `case/cpp_basics/class_inheritance/q05_static_member_init`

---

## 题目：struct加static变量/虚函数后大小变化？

### 标准准确的说法
- 加 `static` 成员：通常不会改变对象大小，因为它不在对象内。
- 加虚函数：对象通常新增一个 `vptr`，对象大小可能增加一个指针大小（再叠加对齐影响）。
- 具体数值与 ABI、平台位数和编译器实现有关。

```cpp
struct S1 { int x; };               // 常见: 4
struct S2 { int x; static int y; }; // 常见: 4
struct S3 { int x; virtual void f(); }; // 常见: 16(64位下,含对齐)
```

### 通俗易懂的理解
- `static` 不进背包；`virtual` 通常会让对象背包里多一个“虚表地址”。

### 面试回答简版模板
`对象大小变化关键看是否新增非静态成员或 vptr；static 成员通常不影响 sizeof。`

### 对应示例
- `case/cpp_basics/class_inheritance/q06_struct_size_with_static_virtual`

---

## 题目：创建10个实例有几个虚函数表？

### 标准准确的说法
- 主流实现中，同一个动态类型通常共享一份 vtable。
- 每个对象有一个 `vptr` 指向该共享 vtable。
- 所以创建 10 个同类对象，通常是 10 个 `vptr`，1 份 vtable。
- 多继承/虚继承场景下可能涉及多张相关表，但“按类型共享”这一点仍成立。

### 通俗易懂的理解
- 通讯录（vtable）是一份公共资料；每个对象只保存通讯录地址（vptr）。

### 面试回答简版模板
`同类对象通常共享一张虚函数表；对象数量增加的是 vptr，不是 vtable 份数。`

### 对应示例
- `case/cpp_basics/class_inheritance/q07_how_many_vtables_for_instances`

---

## 题目：多继承可能出现什么问题？

### 标准准确的说法
- 典型问题：
- 命名冲突与调用二义性（两个基类同名成员）。
- 对象布局复杂（多个基类子对象、指针调整）。
- 菱形继承下可能出现重复公共基类。
- 类型转换更复杂：`Base1*` 到 `Base2*` 可能需要运行时偏移调整。
- 设计层面风险：继承层次过深会提升耦合与维护成本。

```cpp
struct B1 { void log(); };
struct B2 { void log(); };
struct D : B1, B2 {};

// D d; d.log(); // 二义性，需要 d.B1::log();
```

### 通俗易懂的理解
- 多继承像“同时继承两套家规”，容易冲突；技术上能做，设计上要克制。

### 面试回答简版模板
`多继承主要风险是二义性、布局复杂和可维护性下降；需要时用，但优先组合而不是滥用继承。`

### 对应示例
- `case/cpp_basics/class_inheritance/q08_multiple_inheritance_issues`
