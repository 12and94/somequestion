# C++基础：1.5 STL容器

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.5 STL容器` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：map和unordered_map的区别？底层实现？

### 标准准确的说法
- 两者都属于“关联容器”，元素类型本质都是 `std::pair<const Key, T>`，但组织方式完全不同。

1. `std::map`（有序关联容器）
- 典型底层：红黑树（平衡二叉搜索树，标准不强制具体树型，但主流实现如此）。
- 有序语义：
  - 键按比较器 `Compare` 的“严格弱序”组织（默认 `std::less<Key>`）。
  - 支持有序能力：`lower_bound` / `upper_bound` / `equal_range` / 区间遍历。
- 复杂度：
  - 查找/插入/删除：稳定 `O(logN)`。
  - 上界稳定，不依赖哈希分布质量。
- 迭代器与引用稳定性：
  - 插入通常不使已有迭代器失效；
  - 删除仅使被删元素迭代器失效。

2. `std::unordered_map`（无序关联容器）
- 典型底层：哈希表（桶数组 + 冲突处理结构，主流实现常见链式节点组织）。
- 无序语义：
  - 不按键排序；遍历顺序与桶分布、rehash 状态相关，不应依赖。
  - 不提供 `lower_bound/upper_bound` 这类有序范围接口。
- 复杂度：
  - 平均查找/插入/删除 `O(1)`；
  - 最坏 `O(N)`（冲突极端集中、哈希质量差或恶意输入）。
- rehash 与负载因子：
  - 当 `load_factor = size / bucket_count` 超过阈值（`max_load_factor`）时可能 rehash 扩桶。
  - rehash 后桶重排，迭代器通常失效（引用/指针常见仍指向节点对象，但遍历顺序会变化）。

3. 内存与缓存行为差异（常被忽略）
- `map`：
  - 节点含多指针与颜色等元数据，单节点开销较高；
  - 树形跳转对缓存不友好，但顺序与范围能力强。
- `unordered_map`：
  - 额外有桶数组；节点也有链指针/元数据；
  - 点查平均快，但碰撞和 rehash 会带来抖动。

4. 选型决策（实务）
- 选 `map` 的典型信号：
  - 需要按键有序输出；
  - 需要范围查询（区间、前驱后继、边界定位）；
  - 需要可预测上界复杂度。
- 选 `unordered_map` 的典型信号：
  - 主要是点查/点插/点删；
  - 可接受无序；
  - 键哈希分布较好，且会主动做容量与负载因子调优（`reserve` / `max_load_factor`）。

5. 面试可加分细节
- `unordered_map` 并非“绝对 O(1)”，必须强调“平均 O(1), 最坏 O(N)”。
- 当输入可能被构造为冲突攻击（如服务端接口）时，`map` 的稳定上界有时更稳妥。
- 对大批量已知规模数据，`unordered_map` 先 `reserve` 能明显减少 rehash 次数。

6. 红黑树基础（对应 `map`）
- 红黑树是“弱平衡”二叉搜索树，通过颜色约束控制树高在 `O(logN)`。
- 常见性质（面试够用版）：
  - 节点是红或黑；
  - 根为黑；
  - 红节点不能有红孩子（禁止连续红）；
  - 从任一节点到其所有叶子空节点路径的“黑节点数”相同（黑高一致）。
- 这套约束的效果：
  - 不追求绝对平衡，但能保证树不会退化成链表；
  - 查找/插入/删除维持 `O(logN)` 上界。
- 插入/删除后若破坏性质，会通过“旋转 + 变色”修复平衡：
  - 左旋/右旋调整局部结构；
  - 变色修复红黑性质。
- 为什么标准库常选红黑树而不是 AVL：
  - AVL 更“严格平衡”，查找略有优势；
  - 红黑树在更新操作上旋转更少，工程折中更常见。

7. 哈希表基础（对应 `unordered_map`）
- 哈希表核心流程：
  - 用哈希函数 `hash(key)` 把键映射到桶索引；
  - 在桶内处理冲突键（主流实现常见拉链法：桶指向节点链/节点组）。
- 三个关键指标：
  - 哈希函数质量（分布是否均匀）；
  - 桶数量 `bucket_count`；
  - 负载因子 `load_factor = size / bucket_count`。
- 冲突处理与复杂度关系：
  - 冲突少时，桶内很短，点查平均接近 `O(1)`；
  - 冲突集中时，桶内退化变长，最坏可到 `O(N)`。
- rehash 机制：
  - 当负载因子过高（超 `max_load_factor`）会扩桶并重哈希；
  - rehash 代价是一次性搬迁所有节点，单次成本高但降低后续冲突；
  - 迭代器通常失效，遍历顺序可能变化。
- 工程调优常见手段：
  - 预估规模后 `reserve(n)`，减少 rehash 次数；
  - 调整 `max_load_factor` 在内存与速度间取平衡；
  - 自定义 `Hash/KeyEqual` 以改进键分布与判等语义。

对比示例：
```cpp
#include <map>
#include <unordered_map>
#include <string>

int main() {
    std::map<int, std::string> om;
    om[10] = "a";
    om[30] = "b";
    om[20] = "c";
    auto it = om.lower_bound(15); // 有序范围能力

    std::unordered_map<int, std::string> um;
    um.reserve(1024);             // 降低 rehash 频率
    um.max_load_factor(0.7f);     // 更低负载因子，减少冲突
    um[10] = "a";
    um[30] = "b";
    um[20] = "c";
    // um.lower_bound(15);        // 无此有序接口
}
```

### 通俗易懂的理解
- `map` 像“按拼音排好的电话簿”：找某人不一定最快，但能顺着区间连续翻。
- `unordered_map` 像“按哈希桶分格子的抽屉”：通常单点拿东西快，但抽屉内外没顺序。
- 你要“顺序和范围”就选电话簿；你要“高频点查”就选抽屉索引。

### 面试回答简版模板
`map 是有序平衡树语义，查改删稳定 O(logN)，支持 lower_bound/区间查询；unordered_map 是哈希表语义，平均 O(1) 但最坏 O(N)，无序且会受冲突与 rehash 影响。是否需要顺序/范围查询，以及是否追求稳定上界，是两者的核心分界线。`

### 对应示例
- `case/cpp_basics/stl_containers/q01_map_vs_unordered_map`

---

## 题目：vector的底层实现？扩容机制？

### 标准准确的说法
- `std::vector` 是“连续内存上的动态数组容器”，可随机访问 `O(1)`，缓存局部性通常优于链式结构。

底层实现细化（建议按“原始内存 vs 已构造对象”理解）：
1. `vector` 先拿到一段原始连续内存（通过 allocator），再在其中按需构造元素对象。
2. 典型边界（概念上）：
   - `begin`：首元素起点
   - `end`：已构造元素终点（`size` 边界）
   - `end_cap`：已分配内存终点（`capacity` 边界）
3. 区间语义：
   - `[begin, end)`：对象已构造，允许访问
   - `[end, end_cap)`：只是预留原始空间，尚未构造对象，不能当元素访问
4. 这就是为什么 `reserve` 后不能直接 `v[i]`（若 `i >= size`）：有容量不代表有对象。

扩容机制细化（`size == capacity` 且插入新元素）：
1. 计算新容量（标准不规定具体倍数，常见约 1.5x~2x）。
2. 分配更大的连续原始内存。
3. 迁移旧元素到新内存：
   - 优先移动构造；
   - 若移动可能抛异常且拷贝更安全，可能回退到拷贝（常见 `move_if_noexcept` 思路）。
4. 在新内存构造本次新增元素。
5. 销毁旧内存中的旧对象并释放旧块。
6. 更新 `begin/end/end_cap`。

异常安全与性能要点：
- 迁移过程中若构造抛异常，实现会按标准保证回滚到安全状态（具体强/基本保证视操作与类型特性而定）。
- 类型的移动构造若 `noexcept`，通常更有利于 `vector` 扩容时走移动路径。

复杂度要分“单次”与“摊还”：
- `push_back/emplace_back`：
  - 不扩容时 `O(1)`
  - 扩容那次 `O(N)`
  - 长序列尾插摊还 `O(1)`（几何扩容摊薄搬迁成本）
- 中间 `insert/erase` 通常 `O(N)`（需搬移后续元素保持连续）。

迭代器/引用/指针失效规则（操作级速查）：
- reallocation 发生时（如扩容）：
  - 所有迭代器、引用、指针全部失效。
- `push_back/emplace_back`：
  - 若不扩容：已有元素的引用/指针/迭代器通常仍有效，但 `end()` 失效（尾后位置变化）。
  - 若扩容：全部失效。
- `insert/emplace(pos, ...)`：
  - 若扩容：全部失效。
  - 若不扩容：`pos` 及其后的迭代器/引用/指针失效；`pos` 前通常仍有效。
- `erase(pos)` / `erase(first,last)`：
  - 被删区间及其后元素相关迭代器/引用/指针失效。
  - 删前元素通常保持有效。
  - `end()` 也会变化。
- `pop_back()`：
  - 被删最后元素相关引用/指针/迭代器失效；`end()` 失效。
- `clear()`：
  - 所有元素被销毁，对这些元素的引用/指针/迭代器失效；
  - `capacity` 通常不变。
- `reserve(n)`：
  - `n <= capacity`：一般不失效；
  - `n > capacity`：触发重分配，全部失效。
- `resize(n)`：
  - 扩大时可能触发重分配（若触发则全部失效）；
  - 缩小时，被移除元素相关引用/迭代器失效，`end()` 变化。
- `shrink_to_fit()`：
  - 非强制请求；若实现执行了重分配，则会导致失效风险。

为什么这些会失效（从底层实现看）：
- 迭代器本质上像“指向当前内存块某位置的游标”，引用/指针本质上直接绑定对象地址。
- 一旦 reallocation，元素会迁移到“新内存块”，旧地址不再是有效元素地址，所以全失效。
- 不发生 reallocation 时，`vector` 仍可能因“中间插删导致后半段搬移”让一部分元素地址变化，因此 `pos` 及后失效。
- `end()` 代表“尾后位置”，只要 `size` 改变，`end()` 基本都要重新获取，不能缓存长期使用。

一个最容易踩坑的例子：
```cpp
std::vector<int> v = {1, 2, 3};
auto it = v.begin();

v.push_back(4); // 可能扩容
// 扩容后 it 可能悬空，继续 *it 或 ++it 都是未定义行为
```

和 `reserve/resize` 的关系（易混）：
- `reserve(n)`：改容量下限，不改 `size`，不构造新元素。
- `resize(n)`：改 `size`；变大时构造新元素，变小时销毁尾部元素。
- 已知规模批量插入前 `reserve` 是降低重分配成本的核心手段。

工程补充：
- `vector` 适合“读多 + 尾部增删 + 随机访问”。
- 频繁头插/中间插删不宜首选 `vector`。
- `vector<bool>` 是位压缩特化，不是普通 `vector<T>` 的等价行为，面试可作为注意点提及。

观察扩容行为示例：
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v;
    std::size_t last_cap = v.capacity();

    for (int i = 0; i < 32; ++i) {
        v.push_back(i);
        if (v.capacity() != last_cap) {
            std::cout << "size=" << v.size()
                      << ", capacity grows: " << last_cap
                      << " -> " << v.capacity() << "\n";
            last_cap = v.capacity();
        }
    }
}
```

减少扩容抖动示例：
```cpp
std::vector<int> v;
v.reserve(100000); // 预留容量，减少多次重分配
for (int i = 0; i < 100000; ++i) v.push_back(i);
```

### 通俗易懂的理解
- `vector` 像一排连续工位：
  - 查第 k 个工位很快（随机访问）。
  - 工位坐满了再来新人，就要整体搬去更大的办公室（扩容）。
  - 偶尔一次搬家很贵，但如果每次都按倍数扩办公室，长期平均到每个入职成本就低了（摊还 `O(1)`）。

### 面试回答简版模板
`vector 是连续内存动态数组，内部维护 begin/end/end_cap 三段边界。size==capacity 时会分配更大连续内存并迁移旧元素（移动优先，必要时拷贝），因此单次扩容 O(N)；但几何增长使尾插摊还 O(1)。扩容会导致迭代器/引用大范围失效，中间插删也通常是 O(N)。工程上可用 reserve 降低重分配成本。`

### 对应示例
- `case/cpp_basics/stl_containers/q02_vector_impl_growth`

---

## 题目：迭代器失效的情况有哪些？

### 标准准确的说法
- 必须按“容器类型 + 操作”判断，不可一概而论。
- 面试高频先答 `vector`，再补“节点容器 vs 哈希容器”的差异。

`vector` 的失效规则（必须会）：
1. 发生 reallocation（扩容）：
   - 所有迭代器、引用、指针全部失效。
   - 原因：底层连续内存整体换块，旧地址不再指向新元素。
2. `push_back/emplace_back` 不扩容：
   - 指向已有元素的迭代器/引用/指针通常仍有效。
   - `end()` 一定失效（尾后位置改变）。
3. `insert/emplace(pos, ...)` 不扩容：
   - `pos` 及其后的迭代器/引用/指针失效，`pos` 前通常有效。
   - 原因：为腾位置，后半段元素会后移，地址改变。
4. `erase(pos)` / `erase(first,last)`：
   - 被删区间及其后元素相关迭代器/引用/指针失效。
   - 原因：删除后后半段前移补洞，地址变化。
5. `pop_back`：
   - 指向被删末元素的迭代器/引用/指针失效；`end()` 失效。
6. `clear`：
   - 全部元素相关迭代器/引用/指针失效；`capacity` 通常保留。
7. `reserve(n)`：
   - `n > capacity`：触发重分配，全部失效。
   - `n <= capacity`：通常不失效。
8. `resize(n)`：
   - 变大且触发重分配：全部失效。
   - 缩小：被删尾元素相关失效，`end()` 失效。

其他常见容器（用于横向对比）：
- `deque`：分段连续；头尾插删相对温和，但中间插删可能让大量迭代器失效。
- `list/forward_list`：节点地址稳定；除被删节点外，其他节点迭代器通常有效。
- `map/set`：树节点稳定；插入通常不使已有迭代器失效，删除只影响被删节点。
- `unordered_map/unordered_set`：普通插入常不影响元素引用；但 `rehash` 会使迭代器大面积失效。

工程安全写法：
- 不长期缓存 `vector` 的迭代器/指针/引用，尤其跨可能扩容的调用边界。
- 批量插入前先 `reserve`，降低重分配次数。
- 删除遍历时，始终用 `erase` 的返回迭代器接续。

```cpp
for (auto it = v.begin(); it != v.end(); ) {
    if (*it % 2 == 0) it = v.erase(it); // 用返回值接续
    else ++it;
}
```

反例（失效后继续用旧迭代器）：
```cpp
std::vector<int> v = {1, 2, 3, 4, 5};
auto it = v.begin() + 2; // 指向 3

v.erase(v.begin()); // 删除 1，后面元素整体前移
// 此时 it 已失效，不能再解引用
// std::cout << *it << "\n"; // 未定义行为
```

### 通俗易懂的理解
- 把迭代器理解成“当前位置坐标”：
  - `vector` 扩容 = 搬家到新楼，所有旧门牌号作废。
  - `erase/insert` = 楼里有人搬位，改动点后面的门牌会整体重排。
  - 所以修改容器后，不要迷信旧坐标，按返回值拿新坐标继续。

### 面试回答简版模板
`迭代器失效要按“容器 + 操作”判断。vector 最关键：扩容时全部失效；不扩容的 push_back 主要是 end() 失效；erase 会让删除点及其后失效。节点容器（list/map）通常更稳定，unordered 容器要警惕 rehash。`

### 对应示例
- `case/cpp_basics/stl_containers/q03_iterator_invalidation`

---

## 题目：emplace_back和push_back的区别？

### 标准准确的说法
- `push_back` 接收一个现成对象（左值拷贝或右值移动）。
- `emplace_back` 接收构造参数，在容器尾部“原位构造”元素。
- 当参数是构造参数而非完整对象时，`emplace_back` 可能减少临时对象。
- 对于已经有现成对象的场景，两者性能差异通常不大。

```cpp
std::vector<std::pair<int, std::string>> v;
v.push_back(std::make_pair(1, "a")); // 先构造 pair 再入容器
v.emplace_back(2, "b");              // 直接在尾部构造 pair
```

### 通俗易懂的理解
- `push_back` 是“先造好再搬进去”，`emplace_back` 是“在容器里就地建”。

### 面试回答简版模板
`需要用构造参数创建元素时优先 emplace_back；已有对象时 push_back 和 emplace_back 差异通常不大。`

### 对应示例
- `case/cpp_basics/stl_containers/q04_emplace_back_vs_push_back`

---

## 题目：vector的reserve和resize的区别？

### 标准准确的说法
- `reserve(n)`：只保证容量至少为 `n`，不改变 `size`，不新增可访问元素。
- `resize(n)`：直接改变 `size`。
- `n` 增大：新增元素会被值初始化/默认初始化。
- `n` 减小：尾部元素被销毁。
- 典型优化：已知要插入大量元素时先 `reserve`，减少扩容次数。

```cpp
std::vector<int> v;
v.reserve(1000); // size 仍为 0
v.resize(10);    // size 变为 10，可访问 v[0..9]
```

### 通俗易懂的理解
- `reserve` 是“先租仓库”；`resize` 是“真的把货物数量改了”。

### 面试回答简版模板
`reserve 管容量不管元素个数，resize 直接改元素个数；批量插入前 reserve 常用于性能优化。`

### 对应示例
- `case/cpp_basics/stl_containers/q05_reserve_vs_resize`

---

## 题目：红黑树的原理？和AVL树的区别？

### 标准准确的说法
- 红黑树通过颜色规则维持“近似平衡”，保证树高 `O(logN)`。
- 关键性质包括：根黑、红节点子节点黑、从任意节点到叶子空节点的黑高相同等。
- AVL 树平衡更严格（任意节点左右子树高度差不超过 1），查询更紧凑，但插删旋转更频繁。
- 红黑树在插删性能和实现复杂度上折中更好，因此常用于 `map/set`。

### 通俗易懂的理解
- AVL 追求“更平”，查找略优；红黑树追求“够平且改动少”，综合更工程化。

### 面试回答简版模板
`红黑树是弱平衡、插删更平滑；AVL 是强平衡、查找略优但更新代价更高。标准库多选红黑树做折中。`

### 对应示例
- `case/cpp_basics/stl_containers/q06_rb_tree_vs_avl`

---

## 题目：vector怎么释放空间？减容机制？

### 标准准确的说法
- 先分清两个层次：
  1. 逻辑层：元素个数（`size`）是否减少。
  2. 物理层：底层缓冲区容量（`capacity`）是否缩小/释放。
- `vector` 的大多数“删除元素”操作只改 `size`，不主动归还 `capacity`，这是为了避免频繁分配/释放导致抖动。

常见操作对 `size/capacity` 的影响：
1. `clear()`：
   - `size -> 0`，元素析构；
   - `capacity` 通常不变（缓存缓冲区，便于后续复用）。
2. `erase(...)` / `pop_back()` / `resize(smaller)`：
   - 只减少元素，不承诺降 `capacity`。
3. `shrink_to_fit()`：
   - 语义是“请求把 capacity 收缩到接近 size”；
   - 这是 non-binding request（非强制），实现可拒绝。
4. `std::vector<T>(v).swap(v)`：
   - 常见“收缩到当前大小”技巧（通过临时对象重建更小缓冲区再交换）。
5. `std::vector<T>().swap(v)`：
   - 常见“清空并尽量释放容量”技巧。

减容/释放的底层路径（机制视角）：
1. 若触发重分配：分配更小缓冲区 -> 迁移保留元素 -> 销毁旧元素 -> 释放旧缓冲区。
2. “释放旧缓冲区”只表示归还给分配器（allocator / CRT 堆管理器）。
3. 分配器是否立刻把内存归还操作系统，不由 `vector` 保证；任务管理器里内存不一定马上下降。

复杂度与失效规则（面试常追问）：
- `clear()`：`O(N)`（析构 N 个元素），通常不重分配；元素相关引用/迭代器失效。
- `shrink_to_fit()` 若执行重分配：可能 `O(N)`；全部迭代器/引用/指针失效。
- `swap` 技巧若涉及重分配/交换底层缓冲区：旧迭代器通常不可继续使用。

工程策略（比“背 API”更重要）：
- 高频循环（如每帧）中，通常宁可保留 `capacity`，避免反复申请释放。
- 低频阶段切换或峰值已过（如大场景加载结束）再做一次显式收缩更合理。
- 已知后续还会回到类似峰值，过度 shrink 可能适得其反（很快又扩容）。

流程图（面试口述版）：
```text
要不要减容？
  ├─ 后续马上还会长回来 -> 不减（保留 capacity）
  ├─ 峰值已过且很久不用     -> shrink_to_fit / swap 技巧
  └─ 需要彻底清空并尽量回收 -> vector<T>().swap(v)
```

代码示例（观察 size/capacity 变化）：
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v(1'000'000, 1);
    std::cout << "init:   size=" << v.size() << ", cap=" << v.capacity() << "\n";

    v.clear(); // 只清元素，通常不还容量
    std::cout << "clear:  size=" << v.size() << ", cap=" << v.capacity() << "\n";

    v.shrink_to_fit(); // 非强制请求，可能回收，也可能不回收
    std::cout << "shrink: size=" << v.size() << ", cap=" << v.capacity() << "\n";

    std::vector<int>(v).swap(v); // 常见：收缩到当前 size（这里是 0）
    std::cout << "swap1:  size=" << v.size() << ", cap=" << v.capacity() << "\n";

    std::vector<int>().swap(v);  // 常见：清空并尽量回收
    std::cout << "swap2:  size=" << v.size() << ", cap=" << v.capacity() << "\n";
}
```

### 通俗易懂的理解
- `vector` 像仓库：
  - `clear` 是把货物清走，但仓库还租着（capacity 保留）。
  - `shrink_to_fit` 是“申请缩小仓库”，房东可能同意也可能暂时不同意。
  - `swap` 技巧是“换到一个新小仓库，再把旧仓库退掉”，更像显式重建。
- 所以真正的工程问题不是“能不能缩”，而是“现在缩值不值得”。

### 面试回答简版模板
`vector 的减容要区分 size 和 capacity：clear/erase/resize 变小通常只改 size，不主动降 capacity；shrink_to_fit 只是非强制请求。想更确定地收缩，常用重建+swap（如 vector<T>(v).swap(v) 或空 vector swap）。但是否立刻归还 OS 由分配器决定，工程上应避免频繁扩缩导致抖动。`

### 对应示例
- `case/cpp_basics/stl_containers/q07_vector_shrink_release`

---

## 题目：哈希表的实现？哈希冲突如何解决？

### 标准准确的说法
- 哈希表本质是“桶数组 + 桶内冲突管理结构”。
- 基本流程可拆为 4 步：
  1. 计算哈希值：`h = Hash(key)`。
  2. 映射桶索引：`idx = h % bucket_count`（具体映射细节由实现决定）。
  3. 进入桶内查找目标键（比较 `KeyEqual`）。
  4. 查到则命中；查不到则插入（可能触发扩桶 rehash）。

关键概念（必须能说清）：
1. 桶（bucket）：
   - 桶是“第一层分流单位”，不是元素本身。
   - 多个键可能落入同一桶，这就是哈希冲突。
2. 冲突（collision）：
   - 不同 key，经过哈希与索引后落到同一桶。
3. 负载因子（load factor）：
   - `load_factor = size / bucket_count`。
   - 负载因子高，桶内元素更拥挤，冲突概率与查找长度通常上升。

冲突处理主流两大类：
1. 拉链法（separate chaining）
   - 每个桶挂一个节点链（链表/节点组）。
   - 优点：
     - 删除实现自然；
     - 装载因子可 >1；
     - 扩容策略相对灵活。
   - 缺点：
     - 节点分散，缓存局部性较差；
     - 额外指针/节点管理开销。
2. 开放寻址（open addressing）
   - 所有元素都放在表内，冲突时按探测序列找下一个槽位。
   - 常见探测：
     - 线性探测：`idx+i`
     - 二次探测：`idx+i^2`
     - 双重哈希：`idx + i * step(hash2)`
   - 优点：
     - 连续内存局部性好，常数因子可能更优。
   - 缺点：
     - 删除与墓碑处理更复杂；
     - 对装载因子更敏感，接近满表时性能明显恶化。

`unordered_map` 语境下的重要实现点（面试高频）：
- 标准不强制具体内部结构，但主流实现是“桶数组 + 节点（拉链风格）”。
- `Hash` 与 `KeyEqual` 必须语义一致：
  - 若 `KeyEqual(a,b)==true`，应保证 `Hash(a)==Hash(b)`，否则行为语义会出问题。
- rehash 触发：
  - 当 `load_factor()` 超过 `max_load_factor()`，插入时常触发扩桶并重分布。
- rehash 代价：
  - 单次可能接近 `O(N)`，因为要把元素重新分桶。
- 迭代器稳定性：
  - rehash 后迭代器通常失效；
  - 元素引用/指针在主流实现里常可继续指向元素对象，但工程上不要依赖非必要细节。

复杂度表达要完整：
- 平均（哈希分布良好，负载因子受控）：
  - 查找/插入/删除 `O(1)`。
- 最坏（冲突严重，桶极不均匀，甚至被恶意构造）：
  - 可退化到 `O(N)`。
- 面试不要只说“哈希表 O(1)”，必须补“平均 O(1)，最坏 O(N)”。

工程调优要点：
1. 规模可预估时先 `reserve(n)`，减少 rehash 次数。
2. 通过 `max_load_factor(x)` 在“内存占用 vs 查找冲突”之间做权衡。
3. 自定义类型要提供高质量 `Hash` 与一致的 `KeyEqual`。
4. 服务端场景要考虑哈希退化风险（冲突攻击、热点键）。

流程图（口述版）：
```text
key -> Hash(key) -> bucket index
      -> 桶内比较 KeyEqual
          -> 命中: 返回
          -> 未命中:
               插入前检查 load_factor
               -> 超阈值: rehash 后再插
               -> 否则直接插
```

示例（观察桶数量、负载因子、rehash）：
```cpp
#include <iostream>
#include <string>
#include <unordered_map>

int main() {
    std::unordered_map<int, std::string> um;
    um.max_load_factor(0.7f); // 更低阈值，减少桶内拥挤
    um.reserve(16);           // 预估规模，减少扩桶次数

    std::cout << "init buckets=" << um.bucket_count()
              << ", load_factor=" << um.load_factor() << "\n";

    for (int i = 0; i < 50; ++i) {
        um[i] = "v";
        // 观察装载因子变化；超过阈值时插入可能触发 rehash
        if (i % 10 == 9) {
            std::cout << "size=" << um.size()
                      << ", buckets=" << um.bucket_count()
                      << ", load_factor=" << um.load_factor() << "\n";
        }
    }
}
```

### 通俗易懂的理解
- 哈希表像“先按规则分桶，再在桶里找人”：
  - 规则（哈希函数）好，桶分得匀，每个桶人少，查找就快。
  - 规则差或桶太少，很多人挤同一个桶，就会慢。
  - `rehash` 就像“增加桶数量后重新分流”，代价不小但能改善后续查找。

### 面试回答简版模板
`哈希表是桶数组 + 冲突管理。先 Hash(key) 映射桶索引，再在桶内用 KeyEqual 比较。冲突常见用拉链法或开放寻址；unordered_map 实务里要控制 load_factor，必要时 rehash。复杂度应表述为平均 O(1)、最坏 O(N)，并可通过 reserve 和 max_load_factor 做工程调优。`

### 对应示例
- `case/cpp_basics/stl_containers/q08_hash_table_collision`

---

## 题目：常见容器的插入/查找/删除复杂度？

### 标准准确的说法
- 常见复杂度（平均/典型）：
- `vector`：尾插摊还 `O(1)`，中间插删 `O(N)`，按下标访问 `O(1)`。
- `deque`：头尾插删 `O(1)`，随机访问 `O(1)`，中间插删 `O(N)`。
- `list`：已知位置插删 `O(1)`，查找 `O(N)`，随机访问不支持。
- `map/set`：查改删 `O(logN)`。
- `unordered_map/unordered_set`：平均 `O(1)`，最坏 `O(N)`。
- 面试建议补充“复杂度前提”：哈希分布、平衡性质、扩容时机。

### 通俗易懂的理解
- 没有万能容器，只有针对访问模式的最优选择。

### 面试回答简版模板
`先按底层结构给出复杂度，再补一句前提条件：哈希容器是平均 O(1) 不是绝对 O(1)。`

### 对应示例
- `case/cpp_basics/stl_containers/q09_container_complexity_table`

---

## 题目：vector如何O(1)删除元素？

### 标准准确的说法
- 若不要求保序，可用“待删元素与尾元素交换，然后 `pop_back`”实现均摊 `O(1)` 删除。
- 若要求保持顺序，只能 `erase` 并搬移后续元素，复杂度 `O(N)`。
- 该技巧适合实体管理、对象池索引等场景（常见于游戏客户端逻辑层）。

```cpp
void erase_unordered(std::vector<int>& v, size_t idx) {
    v[idx] = std::move(v.back());
    v.pop_back();
}
```

### 通俗易懂的理解
- 不在乎顺序时，直接拿最后一个补洞，速度最快。

### 面试回答简版模板
`vector 想 O(1) 删除只能放弃顺序：尾元素覆盖待删位再 pop_back；若要保序则必然 O(N)。`

### 对应示例
- `case/cpp_basics/stl_containers/q10_vector_o1_erase`

---

## 题目：deque的底层实现？

### 标准准确的说法
- `deque` 不是单块连续内存，常见实现是“分段连续块 + 中控索引表（map）”。
- 优势：头尾插删无需整体搬迁，复杂度稳定。
- 代价：内存布局不如 `vector` 连续，缓存局部性通常稍差。
- 适合频繁头尾操作并需要随机访问的场景。

### 通俗易懂的理解
- `deque` 像“多段车厢拼成的列车”，两头加减车厢很方便。

### 面试回答简版模板
`deque 采用分段存储，兼顾随机访问与高效头尾插删；但连续性不如 vector，缓存友好性通常稍弱。`

### 对应示例
- `case/cpp_basics/stl_containers/q11_deque_impl`

---

## 题目：哪些STL底层是哈希表？

### 标准准确的说法
- C++ 标准库中典型哈希容器：
- `unordered_map`
- `unordered_set`
- `unordered_multimap`
- `unordered_multiset`
- 它们都依赖哈希函数与相等判定器（`Hash`、`KeyEqual`），可自定义。
- 复杂度是“平均 O(1)”语义，而非绝对保证。

### 通俗易懂的理解
- 名字带 `unordered_` 的关联容器，基本就是哈希家族。

### 面试回答简版模板
`标准库的哈希容器主要是四个 unordered_* 关联容器；它们无序、平均 O(1)、依赖哈希质量。`

### 对应示例
- `case/cpp_basics/stl_containers/q12_which_are_hash_based`

---

## 题目：list和vector的区别？

### 标准准确的说法
- `vector`：
- 连续内存，随机访问快，缓存友好。
- 中间插删代价高（需要搬迁）。
- `list`：
- 节点链式存储，随机访问慢（`O(N)`）。
- 已知位置插删 `O(1)`，节点稳定性好。
- 工程中 `vector` 仍更常用，因为现代 CPU 对缓存局部性非常敏感。

### 通俗易懂的理解
- `vector` 像一排连续座位，找人快；`list` 像手拉手队伍，插队方便但按编号找人慢。

### 面试回答简版模板
`vector 胜在连续存储和缓存友好，list 胜在节点级 O(1) 插删；真实工程里 vector 使用率通常更高。`

### 对应示例
- `case/cpp_basics/stl_containers/q13_list_vs_vector`
