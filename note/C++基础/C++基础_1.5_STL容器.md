# C++基础：1.5 STL容器

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.5 STL容器` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：map和unordered_map的区别？底层实现？

### 标准准确的说法
- `std::map`：
- 底层通常是红黑树（平衡二叉搜索树）。
- 键有序，支持有序遍历、`lower_bound/upper_bound` 范围查询。
- 查找/插入/删除复杂度稳定为 `O(logN)`。
- `std::unordered_map`：
- 底层是哈希表（桶数组 + 冲突处理结构）。
- 键无序。
- 平均查找/插入/删除 `O(1)`，最坏 `O(N)`（哈希冲突严重时）。
- 选型：
- 需要顺序、范围查询、稳定复杂度选 `map`。
- 数据量大且以点查为主、键分布良好选 `unordered_map`。

### 通俗易懂的理解
- `map` 像按字典序排好的通讯录，查找略慢但顺序能力强。
- `unordered_map` 像哈希索引表，通常查得快，但顺序是乱的。

### 面试回答简版模板
`map 基于平衡树，O(logN) 且有序；unordered_map 基于哈希表，平均 O(1) 但最坏 O(N) 且无序。是否要范围查询是主要分界线。`

### 对应示例
- `case/cpp_basics/stl_containers/q01_map_vs_unordered_map`

---

## 题目：vector的底层实现？扩容机制？

### 标准准确的说法
- `vector` 是连续内存动态数组，支持随机访问 `O(1)`。
- 关键状态：`size`（已用元素个数）与 `capacity`（已分配容量）。
- 当 `size == capacity` 再 `push_back` 时触发扩容：
- 申请更大连续内存（增长策略由实现决定，常见约 1.5~2 倍）。
- 把旧元素搬迁到新内存（移动优先，不能移动则拷贝）。
- 释放旧内存。
- 复杂度：尾插摊还 `O(1)`，扩容那次为 `O(N)`；中间插删通常 `O(N)`。

```cpp
std::vector<int> v;
v.reserve(8);      // 预留容量，减少重分配次数
for (int i = 0; i < 8; ++i) v.push_back(i);
```

### 通俗易懂的理解
- `vector` 像一整排连续房间，住满了就整体搬到更大的楼里。

### 面试回答简版模板
`vector 的核心是连续存储 + 自动扩容；随机访问快，尾插摊还 O(1)，但扩容或中间插入会触发 O(N) 搬迁。`

### 对应示例
- `case/cpp_basics/stl_containers/q02_vector_impl_growth`

---

## 题目：迭代器失效的情况有哪些？

### 标准准确的说法
- 必须按“容器类型 + 操作”判断，不可一概而论。
- `vector`：
- 扩容后全部迭代器/引用/指针通常失效。
- `erase` 后被删位置及其后的迭代器失效。
- `deque`：头尾插删相对温和，但中间插删可能大范围失效。
- `list/forward_list`：节点稳定，除被删节点外其余迭代器通常不失效。
- `map/set`：插入通常不使已有迭代器失效；删除只使被删元素迭代器失效。
- `unordered_map`：rehash 后迭代器失效（引用通常仍指向节点对象）。
- 安全写法：使用 `erase` 返回值继续迭代，不长期缓存迭代器。

```cpp
for (auto it = v.begin(); it != v.end(); ) {
    if (*it % 2 == 0) it = v.erase(it); // 用返回值接续
    else ++it;
}
```

### 通俗易懂的理解
- 容器结构一旦重排，旧“坐标”就可能失效；删改时要拿新坐标继续走。

### 面试回答简版模板
`迭代器失效要按容器和操作逐个分析；面试里最常考 vector 扩容和 erase 后续失效。`

### 对应示例
- `case/cpp_basics/stl_containers/q03_iterator_invalidation`

---

## 题目：emplace_back和push_back的区别？

### 标准准确的说法
- `push_back` 接收一个现成对象（左值拷贝或右值移动）。
- `emplace_back` 接收构造参数，在容器尾部“原位构造”元素。
- 当参数是构造参数而非完整对象时，`emplace_back` 可能减少临时对象。
- 对于已经有现成对象的场景，两者性能差异通常不大。

```cpp
std::vector<std::pair<int, std::string>> v;
v.push_back(std::make_pair(1, "a")); // 先构造 pair 再入容器
v.emplace_back(2, "b");              // 直接在尾部构造 pair
```

### 通俗易懂的理解
- `push_back` 是“先造好再搬进去”，`emplace_back` 是“在容器里就地建”。

### 面试回答简版模板
`需要用构造参数创建元素时优先 emplace_back；已有对象时 push_back 和 emplace_back 差异通常不大。`

### 对应示例
- `case/cpp_basics/stl_containers/q04_emplace_back_vs_push_back`

---

## 题目：vector的reserve和resize的区别？

### 标准准确的说法
- `reserve(n)`：只保证容量至少为 `n`，不改变 `size`，不新增可访问元素。
- `resize(n)`：直接改变 `size`。
- `n` 增大：新增元素会被值初始化/默认初始化。
- `n` 减小：尾部元素被销毁。
- 典型优化：已知要插入大量元素时先 `reserve`，减少扩容次数。

```cpp
std::vector<int> v;
v.reserve(1000); // size 仍为 0
v.resize(10);    // size 变为 10，可访问 v[0..9]
```

### 通俗易懂的理解
- `reserve` 是“先租仓库”；`resize` 是“真的把货物数量改了”。

### 面试回答简版模板
`reserve 管容量不管元素个数，resize 直接改元素个数；批量插入前 reserve 常用于性能优化。`

### 对应示例
- `case/cpp_basics/stl_containers/q05_reserve_vs_resize`

---

## 题目：红黑树的原理？和AVL树的区别？

### 标准准确的说法
- 红黑树通过颜色规则维持“近似平衡”，保证树高 `O(logN)`。
- 关键性质包括：根黑、红节点子节点黑、从任意节点到叶子空节点的黑高相同等。
- AVL 树平衡更严格（任意节点左右子树高度差不超过 1），查询更紧凑，但插删旋转更频繁。
- 红黑树在插删性能和实现复杂度上折中更好，因此常用于 `map/set`。

### 通俗易懂的理解
- AVL 追求“更平”，查找略优；红黑树追求“够平且改动少”，综合更工程化。

### 面试回答简版模板
`红黑树是弱平衡、插删更平滑；AVL 是强平衡、查找略优但更新代价更高。标准库多选红黑树做折中。`

### 对应示例
- `case/cpp_basics/stl_containers/q06_rb_tree_vs_avl`

---

## 题目：vector怎么释放空间？减容机制？

### 标准准确的说法
- `clear()` 清空元素但通常不释放 capacity。
- `shrink_to_fit()` 是“非强制请求”，实现可能不真正回收。
- 强制回收常用技巧：
- `std::vector<T>(v).swap(v);`
- 或 `std::vector<T>().swap(v);`（清空并回收）。
- 频繁扩容/缩容会引入抖动，需结合业务生命周期设计缓存策略。

```cpp
std::vector<int> v(1000000, 1);
v.clear();                     // 容量可能还在
std::vector<int>().swap(v);    // 常见做法：释放容量
```

### 通俗易懂的理解
- `clear` 只是把货物搬空，不一定退仓库；想退仓库通常要 swap 技巧。

### 面试回答简版模板
`vector 默认不积极还内存；clear 不一定降 capacity，shrink_to_fit 也不保证，常用 swap 技巧显式回收。`

### 对应示例
- `case/cpp_basics/stl_containers/q07_vector_shrink_release`

---

## 题目：哈希表的实现？哈希冲突如何解决？

### 标准准确的说法
- 哈希表流程：
- 通过哈希函数把键映射到桶索引。
- 桶内再处理冲突元素。
- 常见冲突处理：
- 拉链法（链表/节点数组挂桶）。
- 开放寻址（线性探测、二次探测、双重哈希）。
- 负载因子过高会增加冲突与退化风险，通常需要 rehash 扩桶。
- 工程重点：哈希函数质量、装载因子阈值、缓存局部性、扩容成本。

### 通俗易懂的理解
- 哈希表像“按规则分桶放球”；规则不好或桶太少，球就挤在一起，性能下降。

### 面试回答简版模板
`哈希表通过哈希函数定位桶，冲突用拉链或探测法解决；核心是控制负载因子并定期 rehash。`

### 对应示例
- `case/cpp_basics/stl_containers/q08_hash_table_collision`

---

## 题目：常见容器的插入/查找/删除复杂度？

### 标准准确的说法
- 常见复杂度（平均/典型）：
- `vector`：尾插摊还 `O(1)`，中间插删 `O(N)`，按下标访问 `O(1)`。
- `deque`：头尾插删 `O(1)`，随机访问 `O(1)`，中间插删 `O(N)`。
- `list`：已知位置插删 `O(1)`，查找 `O(N)`，随机访问不支持。
- `map/set`：查改删 `O(logN)`。
- `unordered_map/unordered_set`：平均 `O(1)`，最坏 `O(N)`。
- 面试建议补充“复杂度前提”：哈希分布、平衡性质、扩容时机。

### 通俗易懂的理解
- 没有万能容器，只有针对访问模式的最优选择。

### 面试回答简版模板
`先按底层结构给出复杂度，再补一句前提条件：哈希容器是平均 O(1) 不是绝对 O(1)。`

### 对应示例
- `case/cpp_basics/stl_containers/q09_container_complexity_table`

---

## 题目：vector如何O(1)删除元素？

### 标准准确的说法
- 若不要求保序，可用“待删元素与尾元素交换，然后 `pop_back`”实现均摊 `O(1)` 删除。
- 若要求保持顺序，只能 `erase` 并搬移后续元素，复杂度 `O(N)`。
- 该技巧适合实体管理、对象池索引等场景（常见于游戏客户端逻辑层）。

```cpp
void erase_unordered(std::vector<int>& v, size_t idx) {
    v[idx] = std::move(v.back());
    v.pop_back();
}
```

### 通俗易懂的理解
- 不在乎顺序时，直接拿最后一个补洞，速度最快。

### 面试回答简版模板
`vector 想 O(1) 删除只能放弃顺序：尾元素覆盖待删位再 pop_back；若要保序则必然 O(N)。`

### 对应示例
- `case/cpp_basics/stl_containers/q10_vector_o1_erase`

---

## 题目：deque的底层实现？

### 标准准确的说法
- `deque` 不是单块连续内存，常见实现是“分段连续块 + 中控索引表（map）”。
- 优势：头尾插删无需整体搬迁，复杂度稳定。
- 代价：内存布局不如 `vector` 连续，缓存局部性通常稍差。
- 适合频繁头尾操作并需要随机访问的场景。

### 通俗易懂的理解
- `deque` 像“多段车厢拼成的列车”，两头加减车厢很方便。

### 面试回答简版模板
`deque 采用分段存储，兼顾随机访问与高效头尾插删；但连续性不如 vector，缓存友好性通常稍弱。`

### 对应示例
- `case/cpp_basics/stl_containers/q11_deque_impl`

---

## 题目：哪些STL底层是哈希表？

### 标准准确的说法
- C++ 标准库中典型哈希容器：
- `unordered_map`
- `unordered_set`
- `unordered_multimap`
- `unordered_multiset`
- 它们都依赖哈希函数与相等判定器（`Hash`、`KeyEqual`），可自定义。
- 复杂度是“平均 O(1)”语义，而非绝对保证。

### 通俗易懂的理解
- 名字带 `unordered_` 的关联容器，基本就是哈希家族。

### 面试回答简版模板
`标准库的哈希容器主要是四个 unordered_* 关联容器；它们无序、平均 O(1)、依赖哈希质量。`

### 对应示例
- `case/cpp_basics/stl_containers/q12_which_are_hash_based`

---

## 题目：list和vector的区别？

### 标准准确的说法
- `vector`：
- 连续内存，随机访问快，缓存友好。
- 中间插删代价高（需要搬迁）。
- `list`：
- 节点链式存储，随机访问慢（`O(N)`）。
- 已知位置插删 `O(1)`，节点稳定性好。
- 工程中 `vector` 仍更常用，因为现代 CPU 对缓存局部性非常敏感。

### 通俗易懂的理解
- `vector` 像一排连续座位，找人快；`list` 像手拉手队伍，插队方便但按编号找人慢。

### 面试回答简版模板
`vector 胜在连续存储和缓存友好，list 胜在节点级 O(1) 插删；真实工程里 vector 使用率通常更高。`

### 对应示例
- `case/cpp_basics/stl_containers/q13_list_vs_vector`
