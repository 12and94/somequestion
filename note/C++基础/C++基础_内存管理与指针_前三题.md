# C++基础：内存管理与指针（前三题）

本文对应 `面经题目分类汇总.md` 中 `1.1 内存管理与指针` 的前三个问题。  
每个问题统一分为四块：
1. 标准准确的说法
2. 通俗易懂的理解
3. 面试回答简版模板
4. 对应示例

---

## 题目 1：new 和 malloc 的区别？delete 和 free 的区别？

### 标准准确的说法
1. `new/delete` 是 C++ 运算符，`malloc/free` 是 C 标准库函数。
2. `new` 做两件事：分配内存 + 调用构造函数；`delete` 做两件事：调用析构函数 + 释放内存。
3. `malloc` 只分配原始字节，`free` 只释放原始字节，不负责对象构造/析构。
4. `new` 失败默认抛 `std::bad_alloc`；`malloc` 失败返回 `nullptr`。
5. 配对必须正确：`new` 对 `delete`，`new[]` 对 `delete[]`，`malloc` 对 `free`，不能混用。

### 通俗易懂的理解
- `new/delete` 是“按对象”管理内存，适合 C++ 对象。
- `malloc/free` 是“按字节块”管理内存，更底层。
- `new` 像“给你一套装修好的房子”，`malloc` 像“给你一块毛坯地”。

### 面试回答简版模板
`new/delete` 是 C++ 运算符，管对象生命周期；`malloc/free` 是 C 函数，只管字节内存。`new` 会调用构造，`delete` 会调用析构；`malloc/free` 不会。实际 C++ 开发优先 RAII 和智能指针，手写时要注意正确配对、不能混用。

### 对应示例
- `case/cpp_basics/memory_and_pointer/q1_new_malloc_delete_free`

---

## 题目 2：智能指针有哪些？各自原理和区别？

### 标准准确的说法
1. `std::unique_ptr`：独占所有权，不可拷贝、可移动，析构时自动释放资源。
2. `std::shared_ptr`：共享所有权，依赖控制块中的引用计数；计数归零时释放资源。
3. `std::weak_ptr`：弱引用，不增加 `shared_ptr` 计数，不拥有对象；通过 `lock()` 临时获取 `shared_ptr`。
4. `shared_ptr` 循环引用会导致资源无法释放，常用 `weak_ptr` 打破环。

### 通俗易懂的理解
- 智能指针就是“帮你自动回收内存”的工具。
- `unique_ptr` 是“一个对象一个主人”。
- `shared_ptr` 是“多人合租，最后一个离开的人负责关灯”。
- `weak_ptr` 是“只看不拥有”，避免大家互相强引用导致谁也释放不了。

### 面试回答简版模板
默认优先 `unique_ptr`，因为简单且开销小；只有确实需要共享生命周期时才用 `shared_ptr`；只观察不拥有、或者要打破循环引用时用 `weak_ptr`。

### 对应示例
- `case/cpp_basics/memory_and_pointer/q2_smart_pointers`

---

## 题目 3：指针和引用的区别？

### 标准准确的说法
1. 指针是对象，保存地址；引用是已存在对象的别名。
2. 指针可以为 `nullptr`；引用在定义时必须绑定到一个对象（语义上不可为空）。
3. 指针可重绑定到其他对象；引用一旦绑定后不能改绑。
4. 指针访问目标需解引用（`*`、`->`）；引用使用形式与原对象一致。
5. 传参语义上，指针常用于“可空/可选”，引用常用于“必须存在”。

### 通俗易懂的理解
- 指针像“可变门牌号”，你可以换地址，也可以把它设成空。
- 引用像“外号”，本质还是同一个人，外号不会改成别人。

### 面试回答简版模板
指针是地址变量，能为空、能改指向；引用是别名，定义时就得绑定对象，后面不能改绑。需要表达“参数可能没有值”用指针；需要表达“一定有对象”常用引用。

### 对应示例
- `case/cpp_basics/memory_and_pointer/q3_pointer_vs_reference`
