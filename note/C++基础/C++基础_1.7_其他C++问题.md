# C++基础：1.7 其他C++问题

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.7 其他C++问题` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：对象池的实现思路？

### 标准准确的说法
- 对象池通过预分配 + 复用，降低频繁 `new/delete` 成本与内存碎片。
- 核心设计点：
- 空闲链表（free list）或位图管理可用槽位。
- 获取对象时从空闲池取，归还时重置状态后回池。
- 容量策略：固定池、可扩容池、分层池（按对象大小分类）。
- 并发策略：无锁队列/分线程本地池/互斥保护。
- 风险：脏状态复用、对象生命周期混乱、池无限膨胀、跨线程误归还。

```cpp
// 简化思路：对象出池前 init，回池时 reset
struct Bullet { void init(); void reset(); };
```

### 通俗易懂的理解
- 对象池就是“提前备货、反复租用”，避免每次都走昂贵创建流程。

### 面试回答简版模板
`对象池本质是时间换空间：预分配并复用对象，关键在空闲管理、状态重置、容量控制和并发安全。`

### 对应示例
- `case/cpp_basics/other_cpp_topics/q01_object_pool_design`

---

## 题目：单例模式怎么写？

### 标准准确的说法
- 现代 C++ 推荐 Meyers Singleton：函数内静态局部对象。
- C++11 起其初始化具有线程安全保证。
- 典型写法：私有构造，删除拷贝和赋值，仅暴露 `instance()`。
- 风险与权衡：
- 全局状态带来耦合和测试困难。
- 生命周期通常到程序结束，析构时机要与其他全局对象关系谨慎处理。

```cpp
class Logger {
public:
    static Logger& instance() {
        static Logger ins;
        return ins;
    }
private:
    Logger() = default;
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
};
```

### 通俗易懂的理解
- 单例是“全局唯一入口”，用起来方便，但很容易变成“全局依赖扩散”。

### 面试回答简版模板
`实现上优先函数局部静态单例；设计上要警惕全局状态耦合，必要时用依赖注入替代。`

### 对应示例
- `case/cpp_basics/other_cpp_topics/q02_singleton_pattern`

---

## 题目：C++各版本的特性？

### 标准准确的说法
- 高频面试答法建议按时间轴 + 你用过的点：
- C++11：`auto`、`lambda`、右值引用、移动语义、`unique_ptr/shared_ptr`、线程库。
- C++14：泛型 lambda、返回类型推导增强。
- C++17：结构化绑定、`if constexpr`、`optional/variant/any`、`string_view`、并行算法。
- C++20：`concepts`、`ranges`、`coroutine`、`<format>`、`constexpr` 扩展。
- C++23：`std::expected`、`mdspan` 等逐步落地（具体支持看编译器）。
- 面试加分点：把“特性名”映射到“解决了什么工程问题”。

### 通俗易懂的理解
- 版本演进主线是：语法更表达意图、泛型更强、并发和库能力更完整。

### 面试回答简版模板
`我会按 11/17/20 三个里程碑答：11 奠定现代 C++，17 大幅提效编码，20 强化泛型约束与范围编程，并补我项目实际用到的特性。`

### 对应示例
- `case/cpp_basics/other_cpp_topics/q03_cpp_versions_features`

---

## 题目：怎么访问类的private变量？

### 标准准确的说法
- 合法方式：
- 通过 `public` 接口（getter/setter、业务方法）。
- `friend` 受控授权。
- 成员函数内部访问。
- 非法/不推荐方式：通过偏移、重解释强转、UB 黑技巧绕过访问控制。
- 工程观点：面试重点不在“能不能黑进去”，而在“如何设计边界保证封装与可测试性”。

```cpp
class A {
    friend class Inspector;
private:
    int secret_ = 42;
};
```

### 通俗易懂的理解
- 正确答案是“设计访问通道”，不是“想办法撬锁”。

### 面试回答简版模板
`访问 private 的工程做法是通过接口或 friend 受控暴露；绕封装技巧不应作为生产实践。`

### 对应示例
- `case/cpp_basics/other_cpp_topics/q04_access_private_member`

---

## 题目：nullptr上调用成员函数会怎样？

### 标准准确的说法
- 通过空指针调用非静态成员函数通常属于未定义行为（UB）。
- 即使函数体里“看起来没访问成员”，也不能依赖其可运行。
- 编译器可能基于“`this` 非空”前提做优化，UB 会在不同构建选项下表现不一致。
- 静态成员函数不依赖对象实例，不属于该问题范畴。

```cpp
struct A { void f() {} };
A* p = nullptr;
// p->f(); // UB，不可依赖
```

### 通俗易懂的理解
- “有时不崩”只是偶然，不是语言保证。

### 面试回答简版模板
`nullptr 调非静态成员函数是未定义行为，不能作为技巧；需要判空或改为静态/自由函数设计。`

### 对应示例
- `case/cpp_basics/other_cpp_topics/q05_call_member_on_nullptr`

---

## 题目：delete this的使用场景？

### 标准准确的说法
- `delete this` 只有在极严格条件下才可用：
- 对象必须由 `new` 分配。
- 删除后调用路径不再访问该对象。
- 没有其他外部所有者继续使用。
- 典型风险：
- 栈对象误删。
- 删除后继续访问成员导致悬空指针。
- 与异常路径/并发路径叠加后问题更隐蔽。
- 现代实践一般用智能指针和明确所有权模型替代该写法。

### 通俗易懂的理解
- 对象“自杀”很容易留下一堆指向尸体的指针，维护成本高。

### 面试回答简版模板
`delete this 是高风险技巧，除受控框架场景外应避免；现代 C++ 优先智能指针表达生命周期。`

### 对应示例
- `case/cpp_basics/other_cpp_topics/q06_delete_this`

---

## 题目：函数实参的压栈顺序？

### 标准准确的说法
- 不应把“压栈顺序”当作可移植语义来依赖。
- 现代调用约定下实参可能走寄存器，不一定真的“压栈”。
- 参数求值顺序在不同标准阶段/表达式上下文有细节差异，面试里应避免给出绝对化结论。
- 正确工程原则：不要写依赖实参求值先后副作用的代码。

```cpp
int i = 0;
foo(i++, i++); // 不应写这种依赖求值顺序的代码
```

### 通俗易懂的理解
- 这题不是让你背“从左到右还是右到左”，而是看你会不会写可移植代码。

### 面试回答简版模板
`参数传递细节受 ABI 和编译器影响，不能依赖具体压栈顺序；工程上应避免在同一调用里写相互依赖副作用实参。`

### 对应示例
- `case/cpp_basics/other_cpp_topics/q07_argument_eval_order`

---

## 题目：函数指针和成员函数指针的大小？

### 标准准确的说法
- 普通函数指针大小通常等于机器地址宽度（实现相关）。
- 成员函数指针并不等同于“纯地址”：
- 在多继承/虚继承下可能携带额外调整信息。
- 因此其大小可能大于普通函数指针，且在不同编译器/ABI 下差异明显。
- 面试正确姿势：强调“实现相关，不可写死大小假设”。

```cpp
struct A { void f(); };
using FP = void(*)();
using MFP = void(A::*)();
// sizeof(FP) 与 sizeof(MFP) 可能不同
```

### 通俗易懂的理解
- 普通函数指针像“单一地址”；成员函数指针可能是“地址 + 调整规则”。

### 面试回答简版模板
`成员函数指针大小是实现相关，常常不等于普通函数指针，尤其多继承场景可能更大。不要做跨平台硬编码假设。`

### 对应示例
- `case/cpp_basics/other_cpp_topics/q08_func_ptr_vs_member_func_ptr_size`
