# C++基础：1.2 虚函数与多态

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.2 虚函数与多态` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：虚函数的实现原理？虚函数表是什么？

### 标准准确的说法
- 主流 C++ ABI（如 Itanium ABI、MSVC ABI）通常采用 `vptr + vtable` 机制实现动态分发。
- 含虚函数的对象里通常有一个隐藏成员 `vptr`，指向该动态类型对应的虚函数表 `vtable`。
- 通过基类指针/引用调用虚函数时，运行期先读 `vptr`，再按槽位取函数地址进行间接调用。
- 成本主要是：
- 一次间接跳转（可能影响分支预测）。
- 对象体积增加（通常多一个指针）。
- 可能降低内联机会（除非编译器去虚化）。

```cpp
struct Base {
    virtual void run() { std::cout << "Base\n"; }
};
struct Derived : Base {
    void run() override { std::cout << "Derived\n"; }
};

Base* p = new Derived();
p->run(); // 运行期根据 *p 的动态类型分发
```

### 通俗易懂的理解
- 可以把 `vtable` 理解成“函数菜单”，对象里只保存这张菜单的地址。调用虚函数时先找菜单，再跳到真正实现。

### 面试回答简版模板
`虚函数通过对象内的 vptr 指向类级 vtable 来做运行期分发；优势是多态扩展，代价是一次间接调用和一定对象体积开销。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q01_virtual_function_impl`

---

## 题目：多态是什么？如何实现？静态多态和动态多态的区别？

### 标准准确的说法
- 多态本质是“统一接口，对应多种实现”。
- 静态多态：编译期确定调用目标，典型是函数重载、模板实例化、CRTP。
- 动态多态：运行期确定调用目标，依赖继承体系 + 虚函数 + 基类指针/引用。
- 两者侧重点：
- 静态多态通常更利于优化（内联、常量传播），但接口扩展常需重新编译。
- 动态多态扩展性好（运行期替换实现），但有分发开销和继承耦合。

### 通俗易懂的理解
- 同样一句调用语句，静态多态像“编译时就决定演谁”，动态多态像“上台前再看演员是谁”。

### 面试回答简版模板
`静态多态在编译期绑定，偏性能；动态多态在运行期绑定，偏扩展。工程里常混用，热点路径偏静态，扩展边界偏动态。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q02_polymorphism_static_dynamic`

---

## 题目：析构函数为什么要是虚函数？

### 标准准确的说法
- 当类被设计为多态基类时，常会通过基类指针删除派生对象。
- 若基类析构不是虚函数，`delete basePtr` 删除派生对象是未定义行为（UB）。
- 常见后果：派生析构不执行，资源泄漏（内存、文件句柄、锁、GPU 资源等）。
- 因此经验法则是：只要类有任意虚函数或预期被多态使用，应提供虚析构。

```cpp
struct Base { virtual ~Base() = default; };
struct Derived : Base { ~Derived() { /* release resource */ } };

Base* p = new Derived();
delete p; // 安全：先 Derived::~Derived，再 Base::~Base
```

### 通俗易懂的理解
- 你用“父类身份证”去注销“子类对象”，必须走虚析构，才能完整清理整套资源。

### 面试回答简版模板
`会被基类指针 delete 的基类必须是虚析构，否则删除派生对象是未定义行为，常见就是派生资源没被释放。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q03_why_virtual_destructor`

---

## 题目：构造函数能否是虚函数？为什么？

### 标准准确的说法
- 构造函数不能声明为虚函数，这是语言层硬规则。
- 原因在于：虚分发依赖对象已具备稳定动态类型和可用 `vptr`，而构造阶段对象尚在建立过程中。
- 如果允许虚构造会产生循环语义：需要先有对象动态类型才能决定构造，但动态类型又由构造过程建立。

### 通俗易懂的理解
- 对象还没“造完”，就谈不上按最终类型做虚分发。

### 面试回答简版模板
`构造函数不能 virtual，因为虚分发前提是对象动态类型已建立，而构造本身正是在建立这个动态类型。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q04_ctor_virtual`

---

## 题目：虚函数表存放在哪里？是每个类一份还是每个对象一份？

### 标准准确的说法
- 主流实现通常是“类级共享 vtable + 对象级持有 vptr”。
- `vtable` 通常位于只读静态区（具体取决于编译器与链接布局）。
- 每个对象只多一个（或多个）`vptr`，因此不会按对象复制整张表。
- 在多继承/虚继承场景中，一个对象可能有多个 `vptr`，但依然是“表共享、指针按对象”。

### 通俗易懂的理解
- 通讯录是整类共享的；每个对象只记“通讯录地址”。

### 面试回答简版模板
`通常每个多态类有共享的 vtable，每个对象有 vptr 指向它；对象增加的是指针，不是整张表。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q05_vtable_location`

---

## 题目：虚函数表什么时候初始化？

### 标准准确的说法
- `vtable` 内容本身由编译器根据类定义生成，通常在编译/链接期确定。
- 对象的 `vptr` 在构造过程中被写入：
- 进入基类构造时先指向基类阶段表。
- 进入派生构造后更新为派生阶段表。
- 最终构造完成后 `vptr` 指向最派生类型对应表。
- 析构过程会反向收缩，`vptr` 也可能按阶段回退。

### 通俗易懂的理解
- 表是提前准备好的；对象出生时按构造层级不断换“当前可用版本”的表地址。

### 面试回答简版模板
`vtable 是静态生成的；vptr 是对象构造时按继承层级逐步设置，最终落到最派生类型。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q06_vtable_init_time`

---

## 题目：多重继承的虚函数表怎么存？有几张表？

### 标准准确的说法
- 多重继承下对象可能包含多个基类子对象，每个多态基类子对象通常都有自己的 `vptr`。
- 通过不同基类视角调用虚函数时，编译器可能需要 `this` 指针调整（pointer adjustment）。
- 因此“有几张表”依赖具体继承图与 ABI：常见是多张相关表或多段表项。
- 这也是多继承比单继承更复杂的核心原因之一：对象布局复杂、调用路径更依赖实现细节。

```cpp
struct B1 { virtual void f(); };
struct B2 { virtual void g(); };
struct D : B1, B2 {
    void f() override;
    void g() override;
};
// D 对象常见会含 B1、B2 两个多态子对象对应的 vptr
```

### 通俗易懂的理解
- 多继承像一栋楼有多个入口，每个入口都有自己的导览图，进门前可能还要先“走几步调整位置”。

### 面试回答简版模板
`多继承通常对应多个 vptr，并伴随 this 指针调整；具体表数量是 ABI 相关，但复杂度显著高于单继承。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q07_multiple_inheritance_vtable`

---

## 题目：静态函数能否声明为虚函数？

### 标准准确的说法
- 静态成员函数不能是虚函数。
- 虚分发依赖对象实例和 `this` 指针；静态成员函数不绑定对象、没有 `this`。
- 因此语义上无法参与覆盖和动态分发，语言规则也禁止。

### 通俗易懂的理解
- 虚函数是“看对象是谁再决定调用谁”；静态函数是“跟对象无关”的类工具函数，根本不在一个机制里。

### 面试回答简版模板
`静态函数没有 this，不具备虚分发前提，不能声明为 virtual。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q08_static_virtual`

---

## 题目：构造函数/析构函数中能否调用虚函数？

### 标准准确的说法
- 语法上可以调用虚函数，但构造/析构阶段的动态分发受限。
- 在基类构造函数里调用虚函数，只会调用当前构造层（通常是基类版本）。
- 在析构过程中同理，分发会沿析构层级逐步收敛，不会再“跳回”更派生层。
- 因此不应在 ctor/dtor 里依赖虚函数做关键扩展逻辑。

```cpp
struct Base {
    Base() { f(); } // 调 Base::f
    virtual void f() { std::cout << "Base\n"; }
};
struct Derived : Base {
    void f() override { std::cout << "Derived\n"; }
};
```

### 通俗易懂的理解
- 对象在“施工中/拆除中”，多态被限制为当前施工层，不能当作完整运行态对象。

### 面试回答简版模板
`构造/析构中可以调用虚函数，但只按当前层分发，不能依赖完整多态行为。关键初始化逻辑不要放在这类虚调用上。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q09_virtual_call_in_ctor_dtor`

---

## 题目：哪些函数不能是虚函数？

### 标准准确的说法
- 构造函数不能是虚函数。
- 静态成员函数不能是虚函数。
- 非成员函数不能是虚函数（`virtual` 仅用于类成员函数声明）。
- 友元函数不是成员函数，也不能是虚函数。
- 另外，函数模板本身不参与虚覆盖机制（可以有虚成员函数，也可以有模板成员函数，但两者机制不同）。

### 通俗易懂的理解
- 虚函数的前提是“成员函数 + 绑定对象实例 + 可覆盖”，不满足就不能 virtual。

### 面试回答简版模板
`不能 virtual 的典型是构造函数、静态函数、非成员/友元函数；判断标准是是否具备对象级动态分发语义。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q10_non_virtual_candidates`

---

## 题目：基类不使用虚析构函数会发生什么？

### 标准准确的说法
- 若通过基类指针删除派生对象，且基类析构非虚，则行为是未定义的。
- 常见“表象”是只调用基类析构，派生资源未释放，但 UB 不保证固定表现。
- 即便测试中偶尔“看起来正常”，也不能作为正确性依据。
- 这个规则是多态层次设计的红线之一。

### 通俗易懂的理解
- 你以为拆了整栋楼，实际上可能只拆了门厅，后面资源全残留。

### 面试回答简版模板
`基类若会被多态 delete，就必须给虚析构；否则 delete 基类指针删除派生对象属于未定义行为。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q11_base_without_virtual_dtor`

---

## 题目：inline可以修饰虚函数吗？

### 标准准确的说法
- 语法上可以，`inline virtual` 合法。
- 但 `inline` 不保证必然内联，特别是通过基类指针的虚调用点通常难以内联。
- 若编译器能去虚化（例如目标动态类型在当前上下文可静态推断），仍可能内联。
- 因此“virtual + inline”并不矛盾，但最终性能由优化器和调用形态决定。

### 通俗易懂的理解
- `inline` 是“可尝试内联”的建议，遇到真实多态调用时经常不生效；能不能内联看编译器是否看穿类型。

### 面试回答简版模板
`virtual 可以配 inline，但 inline 不是强制；是否内联取决于调用点能否去虚化和优化器决策。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q12_inline_virtual`

---

## 题目：纯虚函数是什么？

### 标准准确的说法
- 纯虚函数声明形式是 `virtual Ret f(...) = 0;`。
- 含至少一个纯虚函数的类是抽象类，不能直接实例化。
- 派生类若未实现全部纯虚函数，依然是抽象类。
- 纯虚函数用于定义接口契约，把“可变实现”和“稳定调用面”分离。
- 抽象基类通常也应有虚析构，避免多态删除风险。

```cpp
struct IShape {
    virtual double area() const = 0;
    virtual ~IShape() = default;
};
```

### 通俗易懂的理解
- 纯虚函数就是“先定规则，不给默认实现”；具体类必须把规则补全才能实例化。

### 面试回答简版模板
`纯虚函数用于定义抽象接口；抽象类不能实例化，具体派生类必须实现接口，并通常配虚析构。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q13_pure_virtual`

---

## 题目：虚函数在大型项目中有什么问题？

### 标准准确的说法
- 性能层面：
- 高频虚调用降低内联机会，可能带来间接跳转和预测失败。
- 数据/代码局部性也可能受影响。
- 架构层面：
- 过深继承树和过宽虚接口会增加耦合，降低重构速度。
- 接口演进时容易产生“基类膨胀”。
- 工程层面：
- 跨模块 ABI 稳定性、对象布局兼容、插件边界会更敏感。
- 常见缓解：
- 热点路径去虚化（`final`、LTO、静态多态）。
- 组合优先于继承。
- 接口保持小而稳定，避免“万能基类”。

### 通俗易懂的理解
- 虚函数是扩展利器，但用多了会让性能和架构都变“重”。关键不是禁用，而是把它放在真正需要扩展的边界上。

### 面试回答简版模板
`大型项目里虚函数主要问题是热点性能损耗和继承耦合；实践上通过热点去虚化、组合优先、接口收敛来平衡扩展性与性能。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q14_virtual_large_project_issues`
