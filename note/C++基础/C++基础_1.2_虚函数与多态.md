# C++基础：1.2 虚函数与多态

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.2 虚函数与多态` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：虚函数的实现原理？虚函数表是什么？

### 标准准确的说法
- 先给定义：
- `虚函数`：在基类中用 `virtual` 声明，允许派生类重写，并在“基类指针/引用调用”时按对象动态类型决定实际执行函数。
- `动态分发（dynamic dispatch）`：调用目标不是编译期写死，而是在运行期根据对象真实类型选择。
- 主流 ABI（Itanium ABI、MSVC ABI）通常采用 `vptr + vtable`：
- `vtable`（虚函数表）：类级别的一张函数地址表，记录该动态类型下各虚函数槽位对应实现。
- `vptr`（虚表指针）：对象里的隐藏指针，指向该对象当前动态类型对应的 `vtable`。
- 运行期调用路径（基类指针/引用场景）：
- 读对象内 `vptr`。
- 按函数槽位在 `vtable` 取出目标函数地址。
- 进行一次间接调用（indirect call）。
- “动态类型”与“静态类型”区别：
- 静态类型是变量声明类型（如 `Base*`）。
- 动态类型是对象真实类型（如 `new Derived`）。
- 构造/析构阶段要点：
- 对象在构造链和析构链中，`vptr` 会分阶段设置。
- 因此构造/析构中虚调用不会按完整最终动态类型扩展，这是常见面试坑点。
- 成本与收益：
- 收益：可扩展的多态接口、解耦调用方与实现方。
- 成本：一次间接跳转、对象通常多一个指针体积、内联机会可能下降。
- 但若编译器可去虚化（devirtualization），仍可优化到接近静态调用。

```cpp
struct Base {
    virtual ~Base() = default;
    virtual void run() { std::cout << "Base\n"; }
};

struct Derived : Base {
    void run() override { std::cout << "Derived\n"; }
};

int main() {
    Base* p = new Derived();
    p->run();
    // 运行期流程可理解为：
    // 1) 读取 *p 内部的 vptr
    // 2) 在 vtable 对应槽位取到 Derived::run
    // 3) 间接调用该函数
    delete p;
}
```

### 通俗易懂的理解
- 可以把 `vtable` 看成“这类对象的函数菜单”，对象里只存菜单地址（`vptr`）。
- 调用虚函数时，程序先看对象手里的菜单地址，再按菜单项跳到具体实现。
- 所以同样是 `p->run()`，如果 `p` 实际指向 `Derived`，就会执行 `Derived::run()`。

### 面试回答简版模板
`虚函数是支持运行期多态的成员函数。主流实现用“对象内 vptr 指向类级 vtable”，调用时先读 vptr 再查槽位做间接调用。优势是扩展性，代价是一次间接调用和一定对象体积开销；在可去虚化场景下编译器仍能优化。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q01_virtual_function_impl`

---

## 题目：多态是什么？如何实现？静态多态和动态多态的区别？

### 标准准确的说法
- 先给本质定义：多态是“同一调用接口，在不同类型或不同运行时对象上表现出不同行为”。
- C++ 常见两大路线：
- 静态多态（compile-time polymorphism）：编译期确定调用目标。
- 动态多态（runtime polymorphism）：运行期确定调用目标。

- 静态多态实现 1：函数重载（overload）
- 同一作用域内同名函数，参数列表不同。
- 编译器根据实参类型做重载决议（overload resolution）。
- 这是语法层面的“同名多实现”，不依赖继承。

```cpp
void log(int) { std::cout << "int\n"; }
void log(double) { std::cout << "double\n"; }

log(1);    // 编译期选 log(int)
log(1.0);  // 编译期选 log(double)
```

- 静态多态实现 2：模板实例化（template instantiation）
- 模板是泛型蓝图，使用处按具体类型生成实例代码。
- 调用目标和类型在编译期已固定，优化器更容易内联与常量传播。
- 常见代价是代码膨胀（多个类型实例化多份代码）。

```cpp
template<class T>
T add(T a, T b) { return a + b; }

auto x = add(1, 2);       // add<int>
auto y = add(1.0, 2.0);   // add<double>
```

- 静态多态实现 3：CRTP（Curiously Recurring Template Pattern）
- 写法：`Derived : Base<Derived>`。
- 基类模板通过 `static_cast<Derived*>(this)` 调用派生实现。
- 本质仍是编译期分发，不走虚函数表。

```cpp
template<class D>
struct Base {
    void interface() { static_cast<D*>(this)->impl(); }
};

struct A : Base<A> {
    void impl() { std::cout << "A::impl\n"; }
};
```

- 动态多态成立的条件链（缺一不可）：
- 条件 1：存在继承层次（Base/Derived）。
- 条件 2：基类函数是 `virtual`，派生类做兼容签名重写（建议 `override`）。
- 条件 3：通过基类指针或基类引用调用。
- 满足后，运行期按对象动态类型分发到最终覆写版本。

```cpp
struct Base {
    virtual ~Base() = default;
    virtual void run() { std::cout << "Base\n"; }
};

struct Derived : Base {
    void run() override { std::cout << "Derived\n"; }
};

Base* p = new Derived();
p->run(); // 运行期分发到 Derived::run
```

- 动态多态常见误区（面试高频追问）：
- 误区 1：对象切片（object slicing）
- `Base b = Derived{};` 会丢失派生部分，后续不再有派生动态行为。
- 误区 2：签名不一致导致“没重写上”
- 参数、`const`、引用限定符不同都会导致重写失败，`override` 能在编译期兜底。
- 误区 3：构造/析构中虚调用
- 这两个阶段虚调用只在当前层级分发，不按最终动态类型扩展。

- 两类多态的工程取舍：
- 静态多态：
- 优势：性能友好、优化空间大。
- 代价：接口扩展常需重新编译，二进制稳定性要求高时不够灵活。
- 动态多态：
- 优势：运行期可替换实现，适合插件化、模块边界抽象。
- 代价：虚调用开销、对象体积开销、继承耦合和可维护性成本。
- 实务建议：热点路径偏静态，扩展边界偏动态，避免“全项目只用一种”。

### 通俗易懂的理解
- 重载：同一名字，编译器看参数提前选演员。
- 模板实例化：先写通用剧本，编译时按角色生成专属剧本。
- CRTP：不走虚函数，靠模板把“基类接口 -> 派生实现”在编译期接起来。
- 继承 + 虚函数 + 基类指针/引用：这是运行期多态完整链路，调用那一刻才按真实对象选实现。
- 你可以把它记成一句话：
- “静态多态靠编译器，动态多态靠对象真实类型。”

### 面试回答简版模板
`多态是统一接口对应多实现。静态多态在编译期绑定，常见有重载、模板实例化、CRTP；动态多态在运行期绑定，必须满足继承关系 + virtual + 基类指针/引用调用。静态多态偏性能，动态多态偏扩展，工程里一般混用：热路径偏静态，扩展边界偏动态。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q02_polymorphism_static_dynamic`

---
## 题目：析构函数为什么要是虚函数？

### 标准准确的说法
- 当类被设计为多态基类时，常会通过基类指针删除派生对象。
- 若基类析构不是虚函数，`delete basePtr` 删除派生对象是未定义行为（UB）。
- 常见后果：派生析构不执行，资源泄漏（内存、文件句柄、锁、GPU 资源等）。
- 因此经验法则是：只要类有任意虚函数或预期被多态使用，应提供虚析构。

```cpp
struct Base { virtual ~Base() = default; };
struct Derived : Base { ~Derived() { /* release resource */ } };

Base* p = new Derived();
delete p; // 安全：先 Derived::~Derived，再 Base::~Base
```

### 通俗易懂的理解
- 你用“父类身份证”去注销“子类对象”，必须走虚析构，才能完整清理整套资源。

### 面试回答简版模板
`会被基类指针 delete 的基类必须是虚析构，否则删除派生对象是未定义行为，常见就是派生资源没被释放。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q03_why_virtual_destructor`

---

## 题目：构造函数能否是虚函数？为什么？

### 标准准确的说法
- 构造函数不能声明为虚函数（语言规则，编译期直接拒绝）。
- 根本原因是“虚分发前提”和“构造阶段状态”冲突：
  - 虚分发要依赖对象已存在且动态类型可用（可通过 `vptr/vtable` 走到最终覆写）。
  - 但构造函数执行时，对象还在“从基类到派生类”逐层建立，动态类型处于过渡态。
- 若允许“虚构造”，语义会自相矛盾：
  - 你想通过动态分发决定“该构造哪种最派生类型”；
  - 但动态类型本身恰恰是构造完成后才稳定下来的结果。
- 构造和虚调用在时间顺序上是：
  - 先分配原始内存；
  - 进入基类构造，`vptr` 先指向基类阶段；
  - 进入派生构造，再切换到派生阶段；
  - 构造完成后对象才成为完整最派生类型。

非法写法（示意）：
```cpp
struct Base {
    // virtual Base(); // 错误：构造函数不能是 virtual
};
```

想“运行时决定创建哪种对象”，正确做法是工厂函数，不是虚构造：
```cpp
#include <memory>

struct Base {
    virtual ~Base() = default;
    virtual void run() = 0;
    static std::unique_ptr<Base> create(int kind);
};

struct A : Base { void run() override {} };
struct B : Base { void run() override {} };

std::unique_ptr<Base> Base::create(int kind) {
    if (kind == 0) return std::make_unique<A>();
    return std::make_unique<B>();
}
```

补充：构造函数里“调虚函数”也不会按最终类型分发：
```cpp
#include <iostream>

struct Base {
    Base() { f(); } // 构造期间调用虚函数
    virtual void f() { std::cout << "Base::f\n"; }
    virtual ~Base() = default;
};

struct Derived : Base {
    void f() override { std::cout << "Derived::f\n"; }
};

int main() {
    Derived d; // 这里通常输出 Base::f，而不是 Derived::f
}
```

### 通俗易懂的理解
- 你可以把它理解成“房子还在施工”：
  - 虚函数像“按最终户型走的导航系统”；
  - 但构造时户型还没完全建好，导航信息不完整。
- 所以语言干脆规定：构造函数不能 virtual；要做“按条件创建对象”，走工厂。

### 面试回答简版模板
`构造函数不能是 virtual，这是语言规则。因为虚分发依赖已建立的动态类型和稳定 vptr，而构造阶段对象正处于分层建立过程中；若允许虚构造会形成语义循环。运行时选择具体类型应使用工厂函数，而不是“虚构造”。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q04_ctor_virtual`
- `case/cpp_basics/virtual_polymorphism/q09_virtual_call_in_ctor_dtor`

---

## 题目：虚函数表存放在哪里？是每个类一份还是每个对象一份？

### 标准准确的说法
- 主流实现通常是“类级共享 vtable + 对象级持有 vptr”。
- `vtable` 通常位于只读静态区（具体取决于编译器与链接布局）。
- 每个对象只多一个（或多个）`vptr`，因此不会按对象复制整张表。
- 在多继承/虚继承场景中，一个对象可能有多个 `vptr`，但依然是“表共享、指针按对象”。

### 通俗易懂的理解
- 通讯录是整类共享的；每个对象只记“通讯录地址”。

### 面试回答简版模板
`通常每个多态类有共享的 vtable，每个对象有 vptr 指向它；对象增加的是指针，不是整张表。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q05_vtable_location`

---

## 题目：虚函数表什么时候初始化？

### 标准准确的说法
- `vtable` 内容本身由编译器根据类定义生成，通常在编译/链接期确定。
- 对象的 `vptr` 在构造过程中被写入：
- 进入基类构造时先指向基类阶段表。
- 进入派生构造后更新为派生阶段表。
- 最终构造完成后 `vptr` 指向最派生类型对应表。
- 析构过程会反向收缩，`vptr` 也可能按阶段回退。

### 通俗易懂的理解
- 表是提前准备好的；对象出生时按构造层级不断换“当前可用版本”的表地址。

### 面试回答简版模板
`vtable 是静态生成的；vptr 是对象构造时按继承层级逐步设置，最终落到最派生类型。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q06_vtable_init_time`

---

## 题目：多重继承的虚函数表怎么存？有几张表？

### 标准准确的说法
- 先说结论：多重继承没有一个“语言层面固定答案”的表数量。  
  C++ 标准只规定语义（能正确动态分发），不规定必须几张表、如何布局；这些由 ABI/编译器实现决定。
- 在实现上，一个对象里会包含多个基类子对象。  
  对于“多态基类子对象”（含虚函数），通常都会有用于虚分发的表指针：
  - Itanium ABI 语境常写 `vptr -> vtable`
  - MSVC 语境常写 `vfptr -> vftable`
- 因为不同基类子对象在对象内偏移不同，`B1*` 和 `B2*` 可能指向同一对象的不同地址。  
  所以经由不同基类指针调用虚函数时，常发生 `this` 调整（pointer adjustment）。
- 典型调用链（以 `B2* pb2` 调到 `D::g` 为例）：
  - 先通过 `pb2` 对应子对象里的表指针找到槽位
  - 槽位可能不是直接 `D::g`，而是一个 thunk（桥接桩函数）
  - thunk 先把 `this` 调整回完整 `D` 对象地址，再跳转到真正实现
- “几张表”常见经验（不是语言保证）：
  - 单继承：常见 1 组主表
  - 非虚多重继承：常见每个多态基类子对象一组相关表/段
  - 含虚继承：还会引入额外偏移信息（如虚基偏移表、更多 thunk），实现更复杂
- 因而面试里应回答“与 ABI 相关 + 每个多态子对象有自己的分发表入口 + 会有 this 调整”，而不是给死数字。

```cpp
struct B1 { virtual void f(); };
struct B2 { virtual void g(); };
struct D : B1, B2 {
    void f() override;
    void g() override;
};
// D 对象常见会含 B1、B2 两个多态子对象对应的 vptr
```

一个常见内存示意（仅示意，非标准强制）：

```text
D object
+---------------------------+
| B1 subobject              |
|   vptr/vfptr (for B1 view)|
+---------------------------+
| B2 subobject              |
|   vptr/vfptr (for B2 view)|
+---------------------------+
| D 自己的数据成员           |
+---------------------------+
```

调用路径示意（以 `B2*` 视角）：

```text
pb2(指向B2子对象)
  -> 读 B2 位置上的表指针
  -> 取 g 槽位
  -> [可能是 thunk] 调整 this
  -> 跳到 D::g 真正实现
```

### 通俗易懂的理解
- 把对象想成一栋楼：`B1` 门和 `B2` 门是两个入口，每个入口都有一张“导览图”（虚函数表）。  
  你从哪个门进，先看到的是该门的导览图。  
  如果最终要去的是“整栋楼统一功能”（`D` 的实现），门口保安会先把你带到正确楼层位置，这一步就是 `this` 调整。
- 所以“有几张表”本质是在问“这栋楼有几个多态入口、每个入口怎么导向最终实现”，不是固定算术题。

### 面试回答简版模板
`多重继承下对象通常含多个多态基类子对象，每个子对象有自己的虚分发表入口。经由不同基类指针调用时常需 this 调整（常通过 thunk 完成）。因此“几张表”由 ABI/编译器决定，不是标准固定值；复杂度显著高于单继承。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q07_multiple_inheritance_vtable`

---

## 题目：静态函数能否声明为虚函数？

### 标准准确的说法
- 结论：静态成员函数不能声明为虚函数（`static` 与 `virtual` 不能同时用于同一成员函数）。
- 原理上两者依赖模型不同，互相冲突：
  - `virtual` 的本质是“对某个对象发起调用，再按该对象的动态类型分发”。
  - 这要求有对象实例和隐式 `this` 指针（`this` 参与寻址、查表、可能还要做 `this` 调整）。
  - `static` 成员函数属于类本身，不绑定对象，没有 `this`，调用可写成 `ClassName::func()`。
- 因此静态函数不具备“覆盖（override）”语义：
  - 派生类里写同名静态函数，发生的是名字隐藏（name hiding），不是虚覆盖。
  - 不能通过基类指针/引用做动态分发到派生的静态函数。
- 这也是为什么“想要多态行为”时，接口必须是非静态虚函数；“静态函数”更适合做与对象状态无关的工具能力。

非法声明示例（编译器会报错）：
```cpp
struct Base {
    // virtual static void f(); // 错误：static 成员函数不能是 virtual
};
```

同名静态函数是“隐藏”，不是“重写”：
```cpp
#include <iostream>

struct Base {
    static void info() { std::cout << "Base::info\n"; }
    virtual void run() { std::cout << "Base::run\n"; }
};

struct Derived : Base {
    static void info() { std::cout << "Derived::info\n"; } // 隐藏 Base::info
    void run() override { std::cout << "Derived::run\n"; } // 真正的虚覆盖
};

int main() {
    Base* p = new Derived;

    p->run();      // 动态分发 -> Derived::run
    p->info();     // 按静态类型 Base* 解析 -> Base::info（很多编译器会给出风格警告）
    Derived::info(); // Derived::info

    delete p;
}
```

如果你要“类级入口 + 多态扩展”，常用替代是“静态工厂 + 虚接口”：
```cpp
#include <memory>

struct Base {
    virtual ~Base() = default;
    virtual void run() = 0; // 多态点必须是非静态虚函数
    static std::unique_ptr<Base> create(); // 类级入口适合 static
};
```

### 通俗易懂的理解
- 虚函数像“根据这辆车的真实型号选驾驶逻辑”；  
  静态函数像“品牌官网上的公共工具页”，跟哪辆具体车无关。
- 既然静态函数不跟对象走，就不存在“按对象真实类型切换实现”这件事。
- 所以它们在语言里被明确分开：要么是对象多态接口（非静态 virtual），要么是类工具接口（static）。

### 面试回答简版模板
`静态成员函数不能是 virtual。virtual 依赖对象实例和 this 做动态分发，而 static 不绑定对象、没有 this，只能做静态绑定；派生类同名 static 只是隐藏，不是 override。需要多态时应使用非静态虚函数，static 更适合工厂/工具入口。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q08_static_virtual`

---

## 题目：构造函数/析构函数中能否调用虚函数？

### 标准准确的说法
- 语法上可以调用虚函数，但构造/析构阶段的动态分发受限。
- 在基类构造函数里调用虚函数，只会调用当前构造层（通常是基类版本）。
- 在析构过程中同理，分发会沿析构层级逐步收敛，不会再“跳回”更派生层。
- 因此不应在 ctor/dtor 里依赖虚函数做关键扩展逻辑。

```cpp
struct Base {
    Base() { f(); } // 调 Base::f
    virtual void f() { std::cout << "Base\n"; }
};
struct Derived : Base {
    void f() override { std::cout << "Derived\n"; }
};
```

### 通俗易懂的理解
- 对象在“施工中/拆除中”，多态被限制为当前施工层，不能当作完整运行态对象。

### 面试回答简版模板
`构造/析构中可以调用虚函数，但只按当前层分发，不能依赖完整多态行为。关键初始化逻辑不要放在这类虚调用上。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q09_virtual_call_in_ctor_dtor`

---

## 题目：哪些函数不能是虚函数？

### 标准准确的说法
- 构造函数不能是虚函数。
- 静态成员函数不能是虚函数。
- 非成员函数不能是虚函数（`virtual` 仅用于类成员函数声明）。
- 友元函数不是成员函数，也不能是虚函数。
- 另外，函数模板本身不参与虚覆盖机制（可以有虚成员函数，也可以有模板成员函数，但两者机制不同）。

### 通俗易懂的理解
- 虚函数的前提是“成员函数 + 绑定对象实例 + 可覆盖”，不满足就不能 virtual。

### 面试回答简版模板
`不能 virtual 的典型是构造函数、静态函数、非成员/友元函数；判断标准是是否具备对象级动态分发语义。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q10_non_virtual_candidates`

---

## 题目：基类不使用虚析构函数会发生什么？

### 标准准确的说法
- 若通过基类指针删除派生对象，且基类析构非虚，则行为是未定义的。
- 常见“表象”是只调用基类析构，派生资源未释放，但 UB 不保证固定表现。
- 即便测试中偶尔“看起来正常”，也不能作为正确性依据。
- 这个规则是多态层次设计的红线之一。

### 通俗易懂的理解
- 你以为拆了整栋楼，实际上可能只拆了门厅，后面资源全残留。

### 面试回答简版模板
`基类若会被多态 delete，就必须给虚析构；否则 delete 基类指针删除派生对象属于未定义行为。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q11_base_without_virtual_dtor`

---

## 题目：inline可以修饰虚函数吗？

### 标准准确的说法
- 语法上可以，`inline virtual` 合法，二者不冲突。
- 先补 `inline` 背景：它在 C++ 里有两层含义。
  - 语言/链接层含义：允许函数在多个翻译单元出现一致定义（常用于头文件），不违反 ODR。
  - 优化层含义：给编译器“可尝试内联”的建议，不是强制展开指令。
- `virtual` 的核心是运行期分发（经由对象动态类型选择最终实现）；调用点常表现为间接调用。
  - 当调用点是真实多态形态（例如 `Base* p; p->f();` 且动态类型未知）时，通常难以内联。
  - 当编译器能去虚化（devirtualization）时，才可能进一步内联：
    - 动态类型可静态确定（如局部对象、明确的具体类型引用）。
    - 类或函数被 `final` 限定，覆写集合可收敛。
    - LTO/PGO 等全局优化提供更多跨模块信息。
- 类内定义的成员函数默认是 `inline`（含虚函数也一样），但这只说明“可内联/可多 TU 一致定义”，不是“必定在每个调用点展开”。
- 因而性能判断不能只看关键字，要看“调用形态 + 编译器优化报告 + 实测”。

合法写法示例：
```cpp
struct Base {
    virtual inline int cost() const { return 1; } // 合法
    virtual ~Base() = default;
};
```

真实多态调用点（通常难以内联）：
```cpp
struct Base {
    virtual int cost() const { return 1; }
    virtual ~Base() = default;
};
struct Derived : Base {
    inline int cost() const override { return 2; }
};

int query(const Base* p) {
    // 调用目标取决于运行时动态类型；常见是间接调用
    return p->cost();
}
```

可去虚化从而可能内联的场景：
```cpp
struct Base {
    virtual int cost() const { return 1; }
    virtual ~Base() = default;
};
struct Derived final : Base {
    inline int cost() const override { return 2; }
};

int direct_call() {
    Derived d;
    // 这里目标类型在当前上下文可确定，优化器可能去虚化并内联
    return d.cost();
}
```

`inline` 的 ODR 语义（头文件常见写法）：
```cpp
// util.h
inline int add(int a, int b) { return a + b; }
// 多个 .cpp 包含该头文件也合法（定义需一致）
```

### 通俗易懂的理解
- `inline` 更像“建议把函数内容贴到调用处”，不是命令。
- `virtual` 是“先看这个对象运行时到底是谁，再决定调哪个函数”。
- 如果编译器在调用点“看不穿对象真实类型”，就很难提前贴代码；看穿了（去虚化）才有机会内联。
- 所以 `inline + virtual` 可以同时出现，但是否真内联要看上下文，不是看关键字数量。

### 面试回答简版模板
`inline virtual 语法合法。inline 在 C++ 既有 ODR 语义（支持头文件一致定义），也只是内联优化建议；virtual 调用点若是运行时多态通常难以内联，只有在可去虚化（如类型可确定、final、LTO/PGO）时才可能被内联。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q12_inline_virtual`
- `note/C++基础/C++基础_1.6_关键字与语法.md`（inline 更系统介绍）

---

## 题目：纯虚函数是什么？

### 标准准确的说法
- 纯虚函数声明形式是 `virtual Ret f(...) = 0;`。
- 含至少一个纯虚函数的类是抽象类，不能直接实例化。
- 派生类若未实现全部纯虚函数，依然是抽象类。
- 纯虚函数用于定义接口契约，把“可变实现”和“稳定调用面”分离。
- 抽象基类通常也应有虚析构，避免多态删除风险。

```cpp
struct IShape {
    virtual double area() const = 0;
    virtual ~IShape() = default;
};
```

### 通俗易懂的理解
- 纯虚函数就是“先定规则，不给默认实现”；具体类必须把规则补全才能实例化。

### 面试回答简版模板
`纯虚函数用于定义抽象接口；抽象类不能实例化，具体派生类必须实现接口，并通常配虚析构。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q13_pure_virtual`

---

## 题目：虚函数在大型项目中有什么问题？

### 标准准确的说法
- 先给结论：虚函数本身不是“错”，问题在于它把“运行期扩展能力”换成了“性能与工程复杂度成本”。  
  在大型项目里，若边界划分不当，这些成本会被放大。

1. 性能层面（热点路径最敏感）
- 间接调用开销：虚调用常通过 `vptr/vtable` 间接跳转，CPU 分支预测和指令流水更难稳定。
- 内联机会下降：调用目标在编译期不可知时，优化器很难跨调用点做内联、常量传播、向量化等联动优化。
- 局部性影响：大规模多态对象常以指针容器出现，数据分散，缓存命中率可能下降。
- 结果：在渲染、物理、路径搜索、序列化等热点循环中，虚调用可能成为“优化墙”。

2. 架构层面（维护成本）
- 继承层级过深：调用链和职责边界不清晰，定位行为来源困难，修改风险扩大。
- 接口过宽（“万能基类”）：一个基类承载过多能力，派生类被迫实现不需要的接口，违背接口隔离。
- 基类膨胀：需求演进时不断往基类加虚函数，导致全局耦合、认知负担和回归风险上升。
- 替换困难：理论上多态便于替换实现，但当基类契约过大，真实替换成本反而更高。

3. 工程与发布层面（大团队/多模块痛点）
- ABI 敏感：跨动态库/插件边界时，vtable 布局、符号可见性、编译器版本和编译选项不一致都会放大风险。
- 接口演进成本：给已发布接口新增虚函数，可能改变槽位布局与二进制兼容行为（尤其跨版本插件生态）。
- 诊断复杂：问题常在“某些平台/某些编译配置/某些插件组合”才暴露，排查链路长。

4. 测试与治理层面（经常被忽视）
- 过度依赖继承做 Mock，容易形成“为测试而设计继承层”的反向耦合。
- 真实行为分散在多层 override 中，代码评审和静态分析难度提升。
- 性能回归不易归因：接口层看似不变，但一次 override 变更可能导致热点路径显著退化。

5. 典型缓解策略（工程实务）
- 热点路径去虚化：
  - 在稳定层级使用 `final` 收敛覆写集合。
  - 打开 LTO/PGO，给优化器更多全局信息。
  - 对高频内核用静态多态（模板/CRTP/`std::variant` 分发）替代动态分发。
- 架构收敛：
  - 组合优先于继承（把可变能力拆成小策略对象）。
  - 基类接口小而稳，避免一次性承载太多职责。
  - 明确“扩展边界层”和“性能核心层”：边界可多态，核心尽量静态化。
- 跨模块策略：
  - 插件边界优先考虑稳定 C ABI（必要时 C++ 内部再做适配层）。
  - 或采用 PImpl/纯 C 接口隔离编译器与 ABI 差异。

热点路径对比示例（同样逻辑，不同分发方式）：
```cpp
#include <vector>

struct Op {
    virtual int eval(int x) const = 0;
    virtual ~Op() = default;
};
struct Add1 : Op {
    int eval(int x) const override { return x + 1; }
};

int sum_virtual(const std::vector<Op*>& ops, int x) {
    int s = 0;
    for (auto* op : ops) {
        s += op->eval(x); // 热点里反复虚调用，可能难以内联
    }
    return s;
}

template <class F>
int sum_static(const std::vector<F>& ops, int x) {
    int s = 0;
    for (const auto& op : ops) {
        s += op(x); // 编译期可见目标，优化器通常更容易联动优化
    }
    return s;
}
```

接口演进与 ABI 风险示意（跨模块时要谨慎）：
```cpp
// v1
struct IRenderer {
    virtual void draw() = 0;
    virtual ~IRenderer() = default;
};

// v2（示意）: 新增虚函数后，已发布插件生态可能出现兼容风险
struct IRendererV2 {
    virtual void draw() = 0;
    virtual void resize(int w, int h) = 0; // 新增
    virtual ~IRendererV2() = default;
};
```

工程建议（可执行清单）：
1. 先量化热点（profile），再决定去虚化，不要凭感觉全量改写。
2. 把“多态”放在模块边界，不放在每帧/每包/每像素内层循环。
3. 基类每新增一个虚函数，都按“ABI + 测试 + 兼容策略”评审。
4. 对跨库接口给出版本策略（版本号、能力查询、适配层）。

### 通俗易懂的理解
- 虚函数像“万能转接头”：非常好用，但每接一层都加一点损耗和复杂度。  
  小项目感受不明显，大项目层层叠加后就会变成性能抖动、改动牵一发动全身、跨模块兼容脆弱。  
  正确做法不是禁用，而是“边界用虚、核心少虚、热点去虚”。

### 面试回答简版模板
`虚函数在大型项目的主要风险是三类：热点路径的间接调用与去内联导致的性能损耗、继承层级与接口膨胀导致的架构耦合、以及跨模块 ABI/版本演进的兼容敏感。工程上通常用“边界多态、核心静态化、热点去虚化（final/LTO/PGO）+ 组合优先 + 小而稳接口 + 明确版本策略”来平衡扩展性与性能。`

### 对应示例
- `case/cpp_basics/virtual_polymorphism/q14_virtual_large_project_issues`
- `case/cpp_basics/virtual_polymorphism/q12_inline_virtual`
