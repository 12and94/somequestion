# C++基础：1.4 移动语义与右值引用

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.4 移动语义与右值引用` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：左值和右值的区别？右值引用是什么？

### 标准准确的说法
- 先记核心：每个表达式都有两个维度  
  - 类型（type）  
  - 值类别（value category）
- 现代 C++ 值类别体系：
  - `lvalue`：有稳定身份，可被多次引用的表达式。
  - `xvalue`：将亡值，仍有身份，但资源可以被“安全搬走”。
  - `prvalue`：纯右值，通常是纯计算结果或临时值来源。
  - `glvalue = lvalue + xvalue`（有身份）
  - `rvalue = prvalue + xvalue`（可移动候选）
- 旧口径“左边/右边”只适合入门，严格语义应看“是否有身份、是否将亡”。

值类别速查（高频表达式）：

| 表达式                  | 值类别     | 说明            |
| -------------------- | ------- | ------------- |
| `x`（变量名）             | lvalue  | 命名对象表达式       |
| `*p`                 | lvalue  | 解引用得到对象身份     |
| `"abc"`              | lvalue  | 字符串字面量是数组左值   |
| `42`、`true`          | prvalue | 字面量纯值         |
| `a + b`              | prvalue | 计算结果          |
| `T{...}`             | prvalue | 临时对象表达式       |
| `std::move(x)`       | xvalue  | 把 `x` 显式转为将亡值 |
| 返回 `T` 的函数调用 `f()`   | prvalue | 按值返回          |
| 返回 `T&` 的函数调用 `g()`  | lvalue  | 引用返回左值        |
| 返回 `T&&` 的函数调用 `h()` | xvalue  | 右值引用返回        |
| `++i`                | lvalue  | 前置++返回对象本身    |
| `i++`                | prvalue | 后置++返回旧值副本    |

引用绑定规则（面试必答）：

| 形参类型 | 可绑定实参 |
|---|---|
| `T&` | 非 const 左值 |
| `const T&` | 左值、右值都可 |
| `T&&` | 右值（`prvalue/xvalue`） |

- 右值引用 `T&&` 的工程意义：
  - 让接口区分“需要保留源对象语义（拷贝）”和“可以转移资源语义（移动）”。
  - 对资源型对象（堆内存、句柄、socket）通常显著减少成本。
- 命名右值引用变量是左值（经典坑）：
  - `T&& rr = ...;` 中 `rr` 是“有名字表达式”，因此是 lvalue。
  - 继续向下游传递“右值语义”时必须 `std::move(rr)`。

C++17 补充：prvalue 实体化（materialization）
- `prvalue` 不总是“立刻产生可寻址临时对象”；在需要对象实体时才发生实体化。
- 这与拷贝消除（尤其返回值优化）结合后，常表现为“少一次拷贝/移动”，所以不要机械地把“prvalue=一定有中间临时对象”。

`decltype` 与值类别（高频追问）
- `decltype(x)`：若 `x` 是变量名，得到声明类型（如 `int`）。
- `decltype((x))`：因为 `(x)` 是 lvalue 表达式，结果是 `int&`。
- 简化记忆：`decltype((expr))` 会“保留 expr 的值类别”映射到引用类型。

值类别与重载决议示例：
```cpp
#include <utility>
#include <iostream>

void f(int& )        { std::cout << "f(int&)\n"; }
void f(const int& )  { std::cout << "f(const int&)\n"; }
void f(int&& )       { std::cout << "f(int&&)\n"; }

int main() {
    int x = 1;
    const int cx = 2;

    f(x);            // 左值 -> f(int&)
    f(cx);           // const左值 -> f(const int&)
    f(3);            // prvalue -> f(int&&)
    f(std::move(x)); // xvalue  -> f(int&&)
}
```

命名右值引用为何还要 `move`：
```cpp
#include <string>
#include <utility>

std::string make();

int main() {
    std::string&& rr = make();       // rr 类型是 &&，但 rr 表达式是左值
    std::string a = rr;              // 通常走拷贝（把 rr 当左值）
    std::string b = std::move(rr);   // 显式转 xvalue，通常走移动
}
```

和转发引用的边界（避免混淆）：
```cpp
template<class T>
void g(T&& arg) { // 这里是“转发引用”，不是固定右值引用
    // arg 若接左值，T 推导为 U&，arg 实际是 U&
    // arg 若接右值，T 推导为 U ，arg 实际是 U&&
}

void h(std::string&& s) { // 这里是“普通右值引用参数”
}
```

成员函数引用限定符与值类别（再进一层）：
```cpp
struct Widget {
    void use() &  { /* 只能对左值对象调用 */ }
    void use() && { /* 只能对右值对象调用 */ }
};

int main() {
    Widget w;
    w.use();          // 调 use() &
    Widget{}.use();   // 调 use() &&
}
```

返回类型如何影响调用方值类别：
```cpp
struct Box {
    int v{0};
    int&  get_l()  { return v; }            // 调用结果是 lvalue
    int&& get_r()  { return std::move(v); } // 调用结果是 xvalue
    int   get_val(){ return v; }            // 调用结果是 prvalue
};
```

常见误区补充：
1. `std::move` 不会移动任何字节，它只是强制类型转换为右值引用。
2. 对 `const` 对象 `std::move` 往往仍无法触发移动（得到 `const T&&`，多数移动操作需要修改源对象）。
3. “右值引用参数”与“转发引用”不是同一个概念，是否模板推导是关键。
4. 返回局部变量时滥用 `return std::move(local);` 可能干扰 NRVO，通常直接 `return local;` 更好（让编译器做返回值优化/移动）。
5. `auto&&` 在推导上下文也可能是转发引用，不要看到 `&&` 就默认“右值引用”。

### 通俗易懂的理解
- 你可以把对象看成“房子 + 家具资源”：
  - 左值是“有门牌号的长期住户”，后面还可能继续住。
  - 右值是“临时住客/即将搬走的人”，可以把家具直接转给新住户，避免重新买一套（拷贝）。
- 右值引用 `T&&` 就像“搬家绿色通道”：告诉编译器这批资源可以转移。
- 但“有名字”的变量（哪怕类型是 `T&&`）都被当成长期住户看待，所以要 `std::move` 显式声明“现在可以搬了”。
- 再补一句：值类别更像“对象当前状态标签”，决定重载匹配、移动是否触发、成员函数 `&/&&` 版本选择。

### 面试回答简版模板
`现代 C++ 按值类别区分表达式：lvalue（有身份）、prvalue（纯值）、xvalue（将亡值）；其中 rvalue=prvalue+xvalue。引用绑定与重载选择都由值类别驱动：T& 接左值，const T& 通吃，T&& 接右值。右值引用用于触发移动语义，但命名后的 T&& 变量本身是左值，继续转交需 std::move；模板里的 T&& 还可能是转发引用，要配合 std::forward 保留原值类别。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q01_lvalue_rvalue`
- `case/cpp_basics/move_semantics_rvalue/q04_perfect_forwarding_ref_collapse`

---

## 题目：移动构造函数和拷贝构造函数的区别？

### 标准准确的说法
- 拷贝构造签名通常是 `T(const T&)`，语义是复制资源，让源和目标都保持各自可用。
- 移动构造签名通常是 `T(T&&) noexcept`，语义是转移资源所有权，让源对象变成“有效但未指定状态”。
- 对资源型对象（堆内存、文件句柄、socket）移动构造通常更高效。
- 若移动构造未声明 `noexcept`，某些容器在扩容迁移时可能回退到拷贝，影响性能。

```cpp
class Buffer {
public:
    Buffer(const Buffer& rhs);            // 深拷贝
    Buffer(Buffer&& rhs) noexcept;        // 资源转移
};
```

### 通俗易懂的理解
- 拷贝是“再买一套房”，移动是“把房产证转给你”。

### 面试回答简版模板
`拷贝构造复制资源，移动构造转移资源；对大对象或资源对象，移动显著降低开销，且建议标注 noexcept。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q02_move_vs_copy_ctor`

---

## 题目：std::move的实现原理？作用是什么？

### 标准准确的说法
- `std::move` 本质是一个无条件类型转换：把表达式转换为右值引用。
- 它不做任何资源搬迁，不会调用 `memcpy` 或系统调用。
- 真正“搬资源”的动作发生在目标类型的移动构造/移动赋值里。
- 对 `const` 对象使用 `std::move` 常无法触发移动（得到 `const T&&`，多数移动操作需要修改源对象）。

```cpp
template<class T>
constexpr std::remove_reference_t<T>&& move(T&& t) noexcept {
    return static_cast<std::remove_reference_t<T>&&>(t);
}
```

### 通俗易懂的理解
- `std::move` 只是贴标签：“这个对象你可以当成临时对象处理了”。

### 面试回答简版模板
`std::move 只做右值转换，不负责搬数据；是否真的移动取决于目标类型是否实现了高质量移动操作。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q03_std_move_principle`

---

## 题目：完美转发是什么？引用折叠规则？

### 标准准确的说法
- 完美转发目标是：在模板包装层中，把参数原本的左值/右值属性和 `const` 属性完整保留给下游。
- 典型写法：
- 形参写 `T&&`（这里是转发引用/万能引用，前提是 `T` 可推导）。
- 转发时写 `std::forward<T>(arg)`。
- 引用折叠核心规则：
- `& + & -> &`
- `& + && -> &`
- `&& + & -> &`
- `&& + && -> &&`
- 误用 `std::move(arg)` 会把左值也强制成右值，破坏语义。

```cpp
template<class T, class... Args>
std::shared_ptr<T> make_obj(Args&&... args) {
    return std::shared_ptr<T>(new T(std::forward<Args>(args)...));
}
```

### 通俗易懂的理解
- 完美转发就是“原样转交快递”，你收到的是左值就按左值交，收到的是右值就按右值交。

### 面试回答简版模板
`模板中要保留实参值类别，用转发引用配合 std::forward；引用折叠是其语义基础。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q04_perfect_forwarding_ref_collapse`

---

## 题目：什么时候需要自己写拷贝构造函数？

### 标准准确的说法
- 当类直接管理资源所有权时（裸指针、文件句柄、互斥量句柄等），默认拷贝往往不满足语义或安全性。
- 若默认拷贝会导致双重释放、共享可变状态冲突、句柄重复关闭等问题，应自定义拷贝语义。
- 若对象不可复制（例如唯一所有权），应显式 `delete` 拷贝构造和拷贝赋值。
- 工程实践优先 Rule of 0：尽量让 `std::string`、`std::vector`、智能指针等成员承担资源管理，减少手写拷贝控制。

```cpp
class UniqueFd {
public:
    UniqueFd(const UniqueFd&) = delete;
    UniqueFd& operator=(const UniqueFd&) = delete;
};
```

### 通俗易懂的理解
- 只要类里有“所有权”，就不能把默认拷贝当成理所当然。

### 面试回答简版模板
`默认拷贝语义不安全或不符合业务语义时，必须自定义或禁用拷贝；能用 Rule of 0 就尽量不手写。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q05_when_custom_copy_ctor`

---

## 题目：深拷贝和浅拷贝的区别？

### 标准准确的说法
- 浅拷贝：仅复制指针值/句柄值，多个对象共享同一底层资源。
- 深拷贝：复制资源本体，目标对象拥有独立副本。
- 对“可释放资源的所有权对象”，浅拷贝常导致双删、并发数据竞争、悬空指针等问题。
- 是否采用深拷贝取决于语义：共享语义可用 `shared_ptr`，独占语义应深拷贝或禁拷贝。

```cpp
struct Bad {
    int* p;
    Bad(const Bad& rhs) : p(rhs.p) {} // 浅拷贝，危险
};

struct Good {
    int* p;
    Good(const Good& rhs) : p(new int(*rhs.p)) {} // 深拷贝
};
```

### 通俗易懂的理解
- 浅拷贝是“复制钥匙编号”，深拷贝是“再建一把新钥匙”。

### 面试回答简版模板
`资源独占类不能做危险浅拷贝；要么深拷贝，要么禁止拷贝并改用移动或智能指针语义。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q06_deep_vs_shallow_copy`

---

## 题目：移动语义和RVO的区别？

### 标准准确的说法
- RVO/NRVO（返回值优化）是编译器优化：直接在目标存储位置构造返回对象，跳过中间临时对象。
- 移动语义是语言机制：在需要对象转移时，用移动构造/赋值替代拷贝。
- C++17 起，部分返回场景有“保证拷贝省略”，甚至不需要移动构造参与。
- 实务上三种路径并存：
- 最优：直接构造（RVO/保证省略）。
- 次优：移动。
- 最差：拷贝。

```cpp
std::string make_name() {
    std::string s = "codex";
    return s; // 可能 NRVO；否则尝试 move
}
```

### 通俗易懂的理解
- RVO 是“根本不搬家，直接在新家建好”；移动是“搬家但尽量少搬重物”。

### 面试回答简版模板
`RVO 是编译器消除中间对象，移动语义是对象间资源转移机制；优先级通常是先看是否可省略，再看能否移动。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q07_move_vs_rvo`

---

## 题目：移动赋值运算符怎么写？

### 标准准确的说法
- 典型签名：`T& operator=(T&& rhs) noexcept`。
- 必做三件事：
- 处理自赋值（`this == &rhs`）。
- 释放当前对象已有资源。
- 接管 `rhs` 资源并将 `rhs` 置为可析构状态（例如置空指针）。
- 若类管理资源，通常要与析构、拷贝构造、拷贝赋值、移动构造一起考虑（Rule of 5）。

```cpp
class Buffer {
public:
    Buffer& operator=(Buffer&& rhs) noexcept {
        if (this == &rhs) return *this;
        delete[] data_;
        data_ = rhs.data_;
        size_ = rhs.size_;
        rhs.data_ = nullptr;
        rhs.size_ = 0;
        return *this;
    }
private:
    char* data_ = nullptr;
    size_t size_ = 0;
};
```

### 通俗易懂的理解
- 移动赋值就是“先把自己旧资源处理掉，再接管对方资源，最后把对方清空到安全状态”。

### 面试回答简版模板
`移动赋值要保证异常安全和资源唯一所有权：自赋值检查、释放旧资源、接管新资源、重置源对象，并建议 noexcept。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q08_move_assignment_operator`
