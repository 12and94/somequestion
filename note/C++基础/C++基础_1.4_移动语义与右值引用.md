# C++基础：1.4 移动语义与右值引用

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.4 移动语义与右值引用` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：左值和右值的区别？右值引用是什么？

### 标准准确的说法
- 先记核心：每个表达式都有两个维度  
  - 类型（type）  
  - 值类别（value category）
- 现代 C++ 值类别体系：
  - `lvalue`：有稳定身份，可被多次引用的表达式。
  - `xvalue`：将亡值，仍有身份，但资源可以被“安全搬走”。
  - `prvalue`：纯右值，通常是纯计算结果或临时值来源。
  - `glvalue = lvalue + xvalue`（有身份）
  - `rvalue = prvalue + xvalue`（可移动候选）
- 旧口径“左边/右边”只适合入门，严格语义应看“是否有身份、是否将亡”。

值类别速查（高频表达式）：

| 表达式                  | 值类别     | 说明            |
| -------------------- | ------- | ------------- |
| `x`（变量名）             | lvalue  | 命名对象表达式       |
| `*p`                 | lvalue  | 解引用得到对象身份     |
| `"abc"`              | lvalue  | 字符串字面量是数组左值   |
| `42`、`true`          | prvalue | 字面量纯值         |
| `a + b`              | prvalue | 计算结果          |
| `T{...}`             | prvalue | 临时对象表达式       |
| `std::move(x)`       | xvalue  | 把 `x` 显式转为将亡值 |
| 返回 `T` 的函数调用 `f()`   | prvalue | 按值返回          |
| 返回 `T&` 的函数调用 `g()`  | lvalue  | 引用返回左值        |
| 返回 `T&&` 的函数调用 `h()` | xvalue  | 右值引用返回        |
| `++i`                | lvalue  | 前置++返回对象本身    |
| `i++`                | prvalue | 后置++返回旧值副本    |

引用绑定规则（面试必答）：

| 形参类型 | 可绑定实参 |
|---|---|
| `T&` | 非 const 左值 |
| `const T&` | 左值、右值都可 |
| `T&&` | 右值（`prvalue/xvalue`） |

- 右值引用 `T&&` 的工程意义：
  - 让接口区分“需要保留源对象语义（拷贝）”和“可以转移资源语义（移动）”。
  - 对资源型对象（堆内存、句柄、socket）通常显著减少成本。
- 命名右值引用变量是左值（经典坑）：
  - `T&& rr = ...;` 中 `rr` 是“有名字表达式”，因此是 lvalue。
  - 继续向下游传递“右值语义”时必须 `std::move(rr)`。

C++17 补充：prvalue 实体化（materialization）
- `prvalue` 不总是“立刻产生可寻址临时对象”；在需要对象实体时才发生实体化。
- 这与拷贝消除（尤其返回值优化）结合后，常表现为“少一次拷贝/移动”，所以不要机械地把“prvalue=一定有中间临时对象”。

`decltype` 与值类别（高频追问）
- `decltype(x)`：若 `x` 是变量名，得到声明类型（如 `int`）。
- `decltype((x))`：因为 `(x)` 是 lvalue 表达式，结果是 `int&`。
- 简化记忆：`decltype((expr))` 会“保留 expr 的值类别”映射到引用类型。

值类别与重载决议示例：
```cpp
#include <utility>
#include <iostream>

void f(int& )        { std::cout << "f(int&)\n"; }
void f(const int& )  { std::cout << "f(const int&)\n"; }
void f(int&& )       { std::cout << "f(int&&)\n"; }

int main() {
    int x = 1;
    const int cx = 2;

    f(x);            // 左值 -> f(int&)
    f(cx);           // const左值 -> f(const int&)
    f(3);            // prvalue -> f(int&&)
    f(std::move(x)); // xvalue  -> f(int&&)
}
```

命名右值引用为何还要 `move`：
```cpp
#include <string>
#include <utility>

std::string make();

int main() {
    std::string&& rr = make();       // rr 类型是 &&，但 rr 表达式是左值
    std::string a = rr;              // 通常走拷贝（把 rr 当左值）
    std::string b = std::move(rr);   // 显式转 xvalue，通常走移动
}
```

和转发引用的边界（避免混淆）：
```cpp
template<class T>
void g(T&& arg) { // 这里是“转发引用”，不是固定右值引用
    // arg 若接左值，T 推导为 U&，arg 实际是 U&
    // arg 若接右值，T 推导为 U ，arg 实际是 U&&
}

void h(std::string&& s) { // 这里是“普通右值引用参数”
}
```

成员函数引用限定符与值类别（再进一层）：
```cpp
struct Widget {
    void use() &  { /* 只能对左值对象调用 */ }
    void use() && { /* 只能对右值对象调用 */ }
};

int main() {
    Widget w;
    w.use();          // 调 use() &
    Widget{}.use();   // 调 use() &&
}
```

返回类型如何影响调用方值类别：
```cpp
struct Box {
    int v{0};
    int&  get_l()  { return v; }            // 调用结果是 lvalue
    int&& get_r()  { return std::move(v); } // 调用结果是 xvalue
    int   get_val(){ return v; }            // 调用结果是 prvalue
};
```

常见误区补充：
1. `std::move` 不会移动任何字节，它只是强制类型转换为右值引用。
2. 对 `const` 对象 `std::move` 往往仍无法触发移动（得到 `const T&&`，多数移动操作需要修改源对象）。
3. “右值引用参数”与“转发引用”不是同一个概念，是否模板推导是关键。
4. 返回局部变量时滥用 `return std::move(local);` 可能干扰 NRVO，通常直接 `return local;` 更好（让编译器做返回值优化/移动）。
5. `auto&&` 在推导上下文也可能是转发引用，不要看到 `&&` 就默认“右值引用”。

### 通俗易懂的理解
- 你可以把对象看成“房子 + 家具资源”：
  - 左值是“有门牌号的长期住户”，后面还可能继续住。
  - 右值是“临时住客/即将搬走的人”，可以把家具直接转给新住户，避免重新买一套（拷贝）。
- 右值引用 `T&&` 就像“搬家绿色通道”：告诉编译器这批资源可以转移。
- 但“有名字”的变量（哪怕类型是 `T&&`）都被当成长期住户看待，所以要 `std::move` 显式声明“现在可以搬了”。
- 再补一句：值类别更像“对象当前状态标签”，决定重载匹配、移动是否触发、成员函数 `&/&&` 版本选择。

### 面试回答简版模板
`现代 C++ 按值类别区分表达式：lvalue（有身份）、prvalue（纯值）、xvalue（将亡值）；其中 rvalue=prvalue+xvalue。引用绑定与重载选择都由值类别驱动：T& 接左值，const T& 通吃，T&& 接右值。右值引用用于触发移动语义，但命名后的 T&& 变量本身是左值，继续转交需 std::move；模板里的 T&& 还可能是转发引用，要配合 std::forward 保留原值类别。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q01_lvalue_rvalue`
- `case/cpp_basics/move_semantics_rvalue/q04_perfect_forwarding_ref_collapse`

---

## 题目：移动构造函数和拷贝构造函数的区别？

### 标准准确的说法
- 拷贝构造签名通常是 `T(const T&)`，语义是复制资源，让源和目标都保持各自可用。
- 移动构造签名通常是 `T(T&&) noexcept`，语义是转移资源所有权，让源对象变成“有效但未指定状态”。
- 对资源型对象（堆内存、文件句柄、socket）移动构造通常更高效。
- 若移动构造未声明 `noexcept`，某些容器在扩容迁移时可能回退到拷贝，影响性能。

```cpp
class Buffer {
public:
    Buffer(const Buffer& rhs);            // 深拷贝
    Buffer(Buffer&& rhs) noexcept;        // 资源转移
};
```

### 通俗易懂的理解
- 拷贝是“再买一套房”，移动是“把房产证转给你”。

### 面试回答简版模板
`拷贝构造复制资源，移动构造转移资源；对大对象或资源对象，移动显著降低开销，且建议标注 noexcept。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q02_move_vs_copy_ctor`

---

## 题目：std::move的实现原理？作用是什么？

### 标准准确的说法
- `std::move` 本质是一个无条件类型转换：把表达式转换为右值引用。
- 它不做任何资源搬迁，不会调用 `memcpy` 或系统调用。
- 真正“搬资源”的动作发生在目标类型的移动构造/移动赋值里。
- 对 `const` 对象使用 `std::move` 常无法触发移动（得到 `const T&&`，多数移动操作需要修改源对象）。

```cpp
template<class T>
constexpr std::remove_reference_t<T>&& move(T&& t) noexcept {
    return static_cast<std::remove_reference_t<T>&&>(t);
}
```

### 通俗易懂的理解
- `std::move` 只是贴标签：“这个对象你可以当成临时对象处理了”。

### 面试回答简版模板
`std::move 只做右值转换，不负责搬数据；是否真的移动取决于目标类型是否实现了高质量移动操作。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q03_std_move_principle`

---

## 题目：完美转发是什么？引用折叠规则？

### 标准准确的说法
- 完美转发（perfect forwarding）的目标：
  - 在“中间包装函数”中，把实参原本的值类别（左值/右值）和 cv 限定尽量不失真地传给下游函数。
  - 让包装层看起来“像不存在一样”，不额外引入拷贝或错误移动。

先解释相关概念（这题经常卡在概念混用）：
1. 右值引用参数 vs 转发引用（forwarding reference）
  - 普通右值引用：`void f(std::string&& x);`，只接右值。
  - 转发引用：`template<class T> void f(T&& x);`，且 `T` 由调用点推导，此时可同时接左值和右值。
  - 关键前提：`T` 必须是“可推导模板参数”。若写成 `void f(const T&&)` 或 `MyType&&`，就不是转发引用。
2. 引用折叠（reference collapsing）
  - 规则：
    - `&  + &  -> &`
    - `&  + && -> &`
    - `&& + &  -> &`
    - `&& + && -> &&`
  - 记忆法：只要出现 `&`，结果通常就是 `&`；只有 `&& + &&` 才保留 `&&`。
3. `std::forward<T>(arg)` 的作用
  - 条件性地保留值类别：
    - 若 `T` 推导为 `U&`，则 `forward<T>(arg)` 是左值。
    - 若 `T` 推导为 `U`，则 `forward<T>(arg)` 是右值。
  - 对比：`std::move(arg)` 是无条件转右值，会把左值也“掰成右值”。

模板推导 + 折叠是怎么联动的（最关键流程）：
- 调用 `wrapper(T&& arg)` 时：
  - 若实参是左值 `u`：
    - `T` 推导为 `U&`
    - 形参类型变成 `U& &&`，折叠后是 `U&`
    - `forward<T>(arg)` 产出左值，保留语义
  - 若实参是右值 `U{}`：
    - `T` 推导为 `U`
    - 形参类型是 `U&&`
    - `forward<T>(arg)` 产出右值，保留语义

经典实现模型（理解用）：
```cpp
template<class T>
constexpr T&& my_forward(std::remove_reference_t<T>& t) noexcept {
    return static_cast<T&&>(t);
}
```

完美转发最小示例（观察重载命中）：
```cpp
#include <iostream>
#include <string>
#include <utility>

void sink(const std::string&) { std::cout << "sink(const&)\n"; }
void sink(std::string&&)      { std::cout << "sink(&&)\n"; }

template<class T>
void wrapper(T&& arg) {
    sink(std::forward<T>(arg)); // 保留传入时的值类别
}

int main() {
    std::string s = "hello";
    wrapper(s);                 // 左值 -> sink(const&)
    wrapper(std::string("x"));  // 右值 -> sink(&&)
}
```

变参完美转发（工厂典型写法）：
```cpp
template<class T, class... Args>
std::shared_ptr<T> make_obj(Args&&... args) {
    return std::shared_ptr<T>(new T(std::forward<Args>(args)...));
}
```

为什么这里不能写 `std::move(args)...`：
- 因为 `args` 中可能有左值实参。
- 若强制 `move`，会把本该保留的左值也变成右值，造成“偷资源”或语义破坏。

常见坑与边界：
1. 命名变量永远是左值
  - 即使类型是 `T&&`，表达式名本身也是左值，所以需要 `forward/move` 再标注语义。
2. `const` 会影响移动
  - `const T` 即便被 `move`，常见也不能调用需要修改源对象的移动重载。
3. 花括号初始化无法直接被完美转发模板参数推导
  - `f({1,2,3})` 常需额外重载或 `std::initializer_list` 支持。
4. 不要重复转发同一个对象
  - 一旦某次转发把对象当右值消费，再次使用可能已是“被移动后状态”。
5. 能不用包装层就不用包装层
  - 包装层越多，越容易在限定符/异常规范/noexcept 上传递失真。

### 通俗易懂的理解
- 完美转发就是“原样转交快递，不擅自拆箱”：
  - 收到左值快递，就按左值交给下游；
  - 收到右值快递，就按右值交给下游；
  - 中间人不乱改签收方式。
- `std::forward` 是“按原始标签转交”，`std::move` 是“统一改成可搬走标签”。

### 面试回答简版模板
`完美转发是模板包装层的值类别保真技术：形参写成可推导的 T&&（转发引用），并用 std::forward<T>(arg) 转发。其语义基础是引用折叠（除了 &&+&& 其余都折叠为 &）。与 std::move 的区别是 forward 保留原值类别，move 无条件转右值；误用 move 会破坏左值语义。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q04_perfect_forwarding_ref_collapse`

---

## 题目：什么时候需要自己写拷贝构造函数？

### 标准准确的说法
- 先给判断准则：当“编译器默认成员拷贝（memberwise copy）”与你的所有权语义不一致时，就需要自己处理拷贝构造（自定义或禁用）。
- 默认拷贝的本质：
  - 对每个成员逐个拷贝。
  - 对裸指针/句柄成员通常只复制“地址/句柄值”，不会自动复制底层资源本体。
  - 这正是浅拷贝风险来源。
- 典型需要你介入的场景：
1. 类直接拥有可释放资源（裸指针、文件句柄、socket、互斥量句柄等）。
2. 业务语义要求“复制后互不影响”，而默认拷贝会共享底层可变状态。
3. 复制成本/策略需要自定义（深拷贝、写时拷贝、引用计数等）。
4. 类型应当不可复制（唯一所有权），需要显式 `=delete`。
- 相关规则要成组理解：
  - Rule of 0：优先让成员类型（`std::string`、`std::vector`、智能指针等）管理资源，你的类尽量不手写特殊成员函数。
  - Rule of 3：若手写了析构/拷贝构造/拷贝赋值之一，通常要一起审视另外两个。
  - Rule of 5：在 C++11+ 下，若你手写了拷贝控制，通常还要同时审视移动构造/移动赋值。
- 什么时候“不要写拷贝构造，直接禁拷贝”：
  - 语义是唯一所有权（如文件描述符 owner、互斥量 owner）。
  - 复制没有明确定义且容易误用。
- 什么时候“要写深拷贝”：
  - 类型语义要求“值语义”（拷贝后互不影响），但成员是原始所有权句柄。
  - 这时至少要提供正确的拷贝构造与拷贝赋值，并保证异常安全。
- 拷贝构造常见触发点（面试常问）：
  - 用同类型对象初始化新对象：`T b = a;` / `T b(a);`
  - 按值传参（若未被优化消除）
  - 函数按值返回（取决于拷贝省略/移动）

默认浅拷贝导致风险示例：
```cpp
struct Bad {
    int* p;
    Bad(int v) : p(new int(v)) {}
    ~Bad() { delete p; }
    // 默认拷贝构造会复制 p 指针值（浅拷贝）
};

int main() {
    Bad a(7);
    Bad b = a; // b.p 和 a.p 指向同一块内存
} // 析构时可能双重释放
```

值语义类的深拷贝 + 移动语义示例：
```cpp
#include <algorithm>
#include <cstddef>
#include <utility>

class Buffer {
public:
    explicit Buffer(std::size_t n = 0) : n_(n), p_(n ? new int[n] : nullptr) {}
    ~Buffer() { delete[] p_; }

    // 深拷贝：复制资源本体
    Buffer(const Buffer& rhs) : n_(rhs.n_), p_(rhs.n_ ? new int[rhs.n_] : nullptr) {
        if (n_) {
            std::copy(rhs.p_, rhs.p_ + n_, p_);
        }
    }

    // 拷贝赋值：copy-and-swap，统一异常安全路径
    Buffer& operator=(Buffer rhs) noexcept {
        swap(rhs);
        return *this;
    }

    // 移动构造：转移所有权
    Buffer(Buffer&& rhs) noexcept : n_(rhs.n_), p_(rhs.p_) {
        rhs.n_ = 0;
        rhs.p_ = nullptr;
    }

    void swap(Buffer& other) noexcept {
        std::swap(n_, other.n_);
        std::swap(p_, other.p_);
    }

private:
    std::size_t n_ = 0;
    int* p_ = nullptr;
};
```

唯一所有权应禁拷贝示例：
```cpp
class UniqueFd {
public:
    UniqueFd(const UniqueFd&) = delete;
    UniqueFd& operator=(const UniqueFd&) = delete;
    UniqueFd(UniqueFd&&) noexcept = default;
    UniqueFd& operator=(UniqueFd&&) noexcept = default;
};
```

### 通俗易懂的理解
- 把默认拷贝理解成“按成员逐个复印”：
  - 对普通值成员没问题；
  - 对资源句柄成员，往往只是复印“钥匙号码”，不是复制“房子本体”。
- 所以一旦类里有“谁负责释放资源”的所有权语义，就必须明确三选一：
  - 让成员类型接管（Rule of 0）；
  - 你自己写深拷贝；
  - 明确禁拷贝（`=delete`）。

### 面试回答简版模板
`当默认成员拷贝与所有权语义冲突时，就需要自己处理拷贝构造：要么实现深拷贝并配套拷贝赋值/析构（C++11 还要审视移动，遵循 Rule of 3/5），要么直接禁拷贝表示唯一所有权。工程上优先 Rule of 0，用标准资源管理成员减少手写拷贝控制。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q05_when_custom_copy_ctor`

---

## 题目：深拷贝和浅拷贝的区别？

### 标准准确的说法
- 浅拷贝：仅复制指针值/句柄值，多个对象共享同一底层资源。
- 深拷贝：复制资源本体，目标对象拥有独立副本。
- 对“可释放资源的所有权对象”，浅拷贝常导致双删、并发数据竞争、悬空指针等问题。
- 是否采用深拷贝取决于语义：共享语义可用 `shared_ptr`，独占语义应深拷贝或禁拷贝。

```cpp
struct Bad {
    int* p;
    Bad(const Bad& rhs) : p(rhs.p) {} // 浅拷贝，危险
};

struct Good {
    int* p;
    Good(const Good& rhs) : p(new int(*rhs.p)) {} // 深拷贝
};
```

### 通俗易懂的理解
- 浅拷贝是“复制钥匙编号”，深拷贝是“再建一把新钥匙”。

### 面试回答简版模板
`资源独占类不能做危险浅拷贝；要么深拷贝，要么禁止拷贝并改用移动或智能指针语义。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q06_deep_vs_shallow_copy`

---

## 题目：移动语义和RVO的区别？

### 标准准确的说法
- 先把概念分开：
1. 移动语义（move semantics）是语言机制  
  - 当对象转移时，用移动构造/移动赋值替代拷贝，核心是“资源所有权转移”。
2. RVO/NRVO 是“对象省略构造路径”  
  - 不是“先构造再移动”，而是“直接在目标存储位置构造”，中间对象根本不产生。
  - RVO：返回临时对象时的省略（如 `return T{...};`）。
  - NRVO：返回具名局部变量时的省略（如 `return local;`）。

- C++17 关键变化（高频面试点）：
  - 对某些 prvalue 返回场景，拷贝省略是“保证的（guaranteed copy elision）”。
  - 结果是：既不拷贝也不移动，移动构造甚至可以不存在。
- 但要区分：
  - `return T{...};` / `return make_T();`（prvalue）常走保证省略。
  - `return local;`（具名局部）通常是 NRVO（可选优化，不是所有场景都保证）。

- 三种路径关系应这样理解：
1. 最优：直接构造（保证省略 / RVO / NRVO）
2. 其次：移动构造（若不能省略且移动可用）
3. 最后：拷贝构造（若移动不可用或不被选中）

- `return std::move(local);` 的常见误区：
  - 在很多场景里它会让 `local` 变成 xvalue，从而破坏 NRVO 机会。
  - 通常推荐直接 `return local;`，让编译器自行做 NRVO 或隐式移动。

- 省略/移动/拷贝决策示意：
```text
return 表达式
  -> 能否保证/实施拷贝省略？ 能 -> 直接构造（无拷贝无移动）
  -> 否 -> 能否调用移动构造？   能 -> 移动
  -> 否 -> 走拷贝构造
```

示例 1：具名局部返回（NRVO 候选）
```cpp
std::string make_name() {
    std::string s = "codex";
    return s; // 可能 NRVO；否则通常尝试移动
}
```

示例 2：prvalue 返回（C++17 常见保证省略）
```cpp
struct T {
    T();
    T(const T&) = delete;
    T(T&&) = delete;
};

T make_t() {
    return T{}; // C++17 下可直接构造返回对象，不依赖拷贝/移动构造
}
```

示例 3：`std::move` 可能抑制 NRVO
```cpp
std::string make_name2() {
    std::string s = "codex";
    return std::move(s); // 常见会变成“显式移动路径”，不利于 NRVO
}
```

补充：移动语义不仅用于“返回值”
- 返回值优化只解决“返回对象构造路径”。
- 移动语义还广泛用于：
  - 容器扩容搬迁元素
  - 赋值替换（`a = std::move(b)`）
  - 资源句柄在对象间转移
- 所以两者不是替代关系，而是“不同层次的成本优化机制”。

### 通俗易懂的理解
- RVO/NRVO 像“新家直接精装交付”，旧家和搬家车都不存在。  
- 移动语义像“有搬家过程，但主要搬房产证和钥匙，不重搬家具”。  
- 面试答题时要强调：能不搬（省略）优先于搬得快（移动）。

### 面试回答简版模板
`移动语义是语言层资源转移机制；RVO/NRVO 是构造路径省略机制。C++17 下部分 prvalue 返回有保证省略，甚至不需要移动构造参与。实际优先级通常是先看是否可省略（最好），不能省略再看移动，最后才是拷贝；因此返回局部变量一般写 return local;，避免无谓 std::move 抑制 NRVO。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q07_move_vs_rvo`

---

## 题目：移动赋值运算符怎么写？

### 标准准确的说法
- 典型签名：`T& operator=(T&& rhs) noexcept`。
- 移动赋值的目标不是“复制内容”，而是“把 rhs 的资源所有权转移到 *this，同时保证双方最终都可析构”。
- 手写移动赋值时要同时满足三件事：
1. 释放/处理当前对象旧资源（避免泄漏）。
2. 接管 `rhs` 资源（指针、句柄、缓冲区等）。
3. 把 `rhs` 置为“有效但未指定状态”（常见做法：置空指针、置零句柄）。
- 自赋值/自移动注意点：
  - 虽然 `a = std::move(a)` 少见，但并非不可能；实现应尽量保持自移动后对象仍可析构、可赋新值。
  - 手写“先释放后接管”方案通常需要 `if (this == &rhs)` 防护。
- `noexcept` 很重要（工程高频）：
  - 标准容器（如 `std::vector`）扩容迁移元素时会优先使用 `noexcept` 移动构造/移动赋值。
  - 若移动操作可能抛异常，容器常回退到拷贝路径，性能和语义都可能受影响。
- 与 Rule of 5 联动：
  - 一旦类自己管理资源并手写了拷贝/析构中的任意一个，通常应一起审视：
    - 析构函数
    - 拷贝构造
    - 拷贝赋值
    - 移动构造
    - 移动赋值
- 什么时候可以 `=default` 移动赋值：
  - 成员都能安全移动，且默认语义符合你的业务语义时，优先 `=default`（最稳）。
- 什么时候移动赋值会被隐式删除（常见边界）：
  - 存在不能赋值的成员（如引用成员、`const` 非静态成员等）；
  - 或基类/成员的移动赋值不可访问/已删除。

手写接管版（资源所有权类）：
```cpp
#include <cstddef>

class Buffer {
public:
    Buffer& operator=(Buffer&& rhs) noexcept {
        if (this == &rhs) return *this; // 防自移动

        delete[] data_;                 // 1) 清理旧资源
        data_ = rhs.data_;              // 2) 接管新资源
        size_ = rhs.size_;
        rhs.data_ = nullptr;            // 3) 置源为安全状态
        rhs.size_ = 0;
        return *this;
    }

private:
    char* data_ = nullptr;
    std::size_t size_ = 0;
};
```

swap 版（异常安全和代码复用更好）：
```cpp
#include <utility>

class Buffer2 {
public:
    Buffer2& operator=(Buffer2&& rhs) noexcept {
        if (this == &rhs) return *this;
        swap(rhs);        // 交换后 rhs 析构会释放旧资源
        return *this;
    }

    void swap(Buffer2& other) noexcept {
        std::swap(data_, other.data_);
        std::swap(size_, other.size_);
    }

private:
    char* data_ = nullptr;
    std::size_t size_ = 0;
};
```

默认移动赋值可用的简洁类型示例：
```cpp
#include <memory>
#include <string>
#include <vector>

struct Good {
    std::string name;
    std::vector<int> values;
    std::unique_ptr<int> p;
    Good& operator=(Good&&) noexcept = default; // 默认移动语义通常就很好
};
```

常见坑：
1. 在移动赋值里忘了释放旧资源 -> 泄漏。
2. 接管后没重置源对象 -> 双重释放风险。
3. 没写 `noexcept` 导致容器迁移回退拷贝。
4. 同时手写了拷贝/析构却没补全 Rule of 5 其他成员。

### 通俗易懂的理解
- 移动赋值就像“换仓库”：
  - 先把自己仓库里旧货处理好；
  - 再把对方仓库钥匙和货单接过来；
  - 最后把对方仓库置为空壳，保证不会两边都去销毁同一批货。
- 比拷贝赋值省的是“复制货物”成本，但前提是你把所有权边界写对。

### 面试回答简版模板
`移动赋值典型签名是 T& operator=(T&&) noexcept。核心是旧资源正确释放、新资源所有权接管、源对象重置到可析构状态，并处理自移动边界。资源类应按 Rule of 5 成组审视，且建议 noexcept 以避免容器迁移回退到拷贝。语义可默认时优先 =default。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q08_move_assignment_operator`
