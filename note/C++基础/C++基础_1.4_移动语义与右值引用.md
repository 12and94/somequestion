# C++基础：1.4 移动语义与右值引用

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.4 移动语义与右值引用` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：左值和右值的区别？右值引用是什么？

### 标准准确的说法
- 在现代 C++ 中更精确的分类是：`lvalue`、`xvalue`、`prvalue`。
- 左值（lvalue）有稳定身份，通常可以取地址并在多条语句中继续使用。
- 右值主要是临时值（`prvalue`）或将亡值（`xvalue`）。
- 右值引用 `T&&` 能绑定到右值，典型用途是把“可被安全转移资源的对象”传给移动构造/移动赋值。
- 命名后的右值引用变量本身是左值，若要继续当右值传递，需显式 `std::move`。

```cpp
std::string make();
std::string a = make();      // 右值初始化
std::string&& rr = make();   // 绑定右值
std::string b = std::move(rr); // rr 有名字，是左值，需 move
```

### 通俗易懂的理解
- 左值像“长期住户”，右值像“临时包裹”。
- 右值引用就是告诉编译器：这个对象马上要走了，可以把里面资源搬走。

### 面试回答简版模板
`左值有稳定身份，右值多是临时对象；右值引用用于承接将亡对象，从而触发移动语义减少资源拷贝。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q01_lvalue_rvalue`

---

## 题目：移动构造函数和拷贝构造函数的区别？

### 标准准确的说法
- 拷贝构造签名通常是 `T(const T&)`，语义是复制资源，让源和目标都保持各自可用。
- 移动构造签名通常是 `T(T&&) noexcept`，语义是转移资源所有权，让源对象变成“有效但未指定状态”。
- 对资源型对象（堆内存、文件句柄、socket）移动构造通常更高效。
- 若移动构造未声明 `noexcept`，某些容器在扩容迁移时可能回退到拷贝，影响性能。

```cpp
class Buffer {
public:
    Buffer(const Buffer& rhs);            // 深拷贝
    Buffer(Buffer&& rhs) noexcept;        // 资源转移
};
```

### 通俗易懂的理解
- 拷贝是“再买一套房”，移动是“把房产证转给你”。

### 面试回答简版模板
`拷贝构造复制资源，移动构造转移资源；对大对象或资源对象，移动显著降低开销，且建议标注 noexcept。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q02_move_vs_copy_ctor`

---

## 题目：std::move的实现原理？作用是什么？

### 标准准确的说法
- `std::move` 本质是一个无条件类型转换：把表达式转换为右值引用。
- 它不做任何资源搬迁，不会调用 `memcpy` 或系统调用。
- 真正“搬资源”的动作发生在目标类型的移动构造/移动赋值里。
- 对 `const` 对象使用 `std::move` 常无法触发移动（得到 `const T&&`，多数移动操作需要修改源对象）。

```cpp
template<class T>
constexpr std::remove_reference_t<T>&& move(T&& t) noexcept {
    return static_cast<std::remove_reference_t<T>&&>(t);
}
```

### 通俗易懂的理解
- `std::move` 只是贴标签：“这个对象你可以当成临时对象处理了”。

### 面试回答简版模板
`std::move 只做右值转换，不负责搬数据；是否真的移动取决于目标类型是否实现了高质量移动操作。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q03_std_move_principle`

---

## 题目：完美转发是什么？引用折叠规则？

### 标准准确的说法
- 完美转发目标是：在模板包装层中，把参数原本的左值/右值属性和 `const` 属性完整保留给下游。
- 典型写法：
- 形参写 `T&&`（这里是转发引用/万能引用，前提是 `T` 可推导）。
- 转发时写 `std::forward<T>(arg)`。
- 引用折叠核心规则：
- `& + & -> &`
- `& + && -> &`
- `&& + & -> &`
- `&& + && -> &&`
- 误用 `std::move(arg)` 会把左值也强制成右值，破坏语义。

```cpp
template<class T, class... Args>
std::shared_ptr<T> make_obj(Args&&... args) {
    return std::shared_ptr<T>(new T(std::forward<Args>(args)...));
}
```

### 通俗易懂的理解
- 完美转发就是“原样转交快递”，你收到的是左值就按左值交，收到的是右值就按右值交。

### 面试回答简版模板
`模板中要保留实参值类别，用转发引用配合 std::forward；引用折叠是其语义基础。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q04_perfect_forwarding_ref_collapse`

---

## 题目：什么时候需要自己写拷贝构造函数？

### 标准准确的说法
- 当类直接管理资源所有权时（裸指针、文件句柄、互斥量句柄等），默认拷贝往往不满足语义或安全性。
- 若默认拷贝会导致双重释放、共享可变状态冲突、句柄重复关闭等问题，应自定义拷贝语义。
- 若对象不可复制（例如唯一所有权），应显式 `delete` 拷贝构造和拷贝赋值。
- 工程实践优先 Rule of 0：尽量让 `std::string`、`std::vector`、智能指针等成员承担资源管理，减少手写拷贝控制。

```cpp
class UniqueFd {
public:
    UniqueFd(const UniqueFd&) = delete;
    UniqueFd& operator=(const UniqueFd&) = delete;
};
```

### 通俗易懂的理解
- 只要类里有“所有权”，就不能把默认拷贝当成理所当然。

### 面试回答简版模板
`默认拷贝语义不安全或不符合业务语义时，必须自定义或禁用拷贝；能用 Rule of 0 就尽量不手写。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q05_when_custom_copy_ctor`

---

## 题目：深拷贝和浅拷贝的区别？

### 标准准确的说法
- 浅拷贝：仅复制指针值/句柄值，多个对象共享同一底层资源。
- 深拷贝：复制资源本体，目标对象拥有独立副本。
- 对“可释放资源的所有权对象”，浅拷贝常导致双删、并发数据竞争、悬空指针等问题。
- 是否采用深拷贝取决于语义：共享语义可用 `shared_ptr`，独占语义应深拷贝或禁拷贝。

```cpp
struct Bad {
    int* p;
    Bad(const Bad& rhs) : p(rhs.p) {} // 浅拷贝，危险
};

struct Good {
    int* p;
    Good(const Good& rhs) : p(new int(*rhs.p)) {} // 深拷贝
};
```

### 通俗易懂的理解
- 浅拷贝是“复制钥匙编号”，深拷贝是“再建一把新钥匙”。

### 面试回答简版模板
`资源独占类不能做危险浅拷贝；要么深拷贝，要么禁止拷贝并改用移动或智能指针语义。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q06_deep_vs_shallow_copy`

---

## 题目：移动语义和RVO的区别？

### 标准准确的说法
- RVO/NRVO（返回值优化）是编译器优化：直接在目标存储位置构造返回对象，跳过中间临时对象。
- 移动语义是语言机制：在需要对象转移时，用移动构造/赋值替代拷贝。
- C++17 起，部分返回场景有“保证拷贝省略”，甚至不需要移动构造参与。
- 实务上三种路径并存：
- 最优：直接构造（RVO/保证省略）。
- 次优：移动。
- 最差：拷贝。

```cpp
std::string make_name() {
    std::string s = "codex";
    return s; // 可能 NRVO；否则尝试 move
}
```

### 通俗易懂的理解
- RVO 是“根本不搬家，直接在新家建好”；移动是“搬家但尽量少搬重物”。

### 面试回答简版模板
`RVO 是编译器消除中间对象，移动语义是对象间资源转移机制；优先级通常是先看是否可省略，再看能否移动。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q07_move_vs_rvo`

---

## 题目：移动赋值运算符怎么写？

### 标准准确的说法
- 典型签名：`T& operator=(T&& rhs) noexcept`。
- 必做三件事：
- 处理自赋值（`this == &rhs`）。
- 释放当前对象已有资源。
- 接管 `rhs` 资源并将 `rhs` 置为可析构状态（例如置空指针）。
- 若类管理资源，通常要与析构、拷贝构造、拷贝赋值、移动构造一起考虑（Rule of 5）。

```cpp
class Buffer {
public:
    Buffer& operator=(Buffer&& rhs) noexcept {
        if (this == &rhs) return *this;
        delete[] data_;
        data_ = rhs.data_;
        size_ = rhs.size_;
        rhs.data_ = nullptr;
        rhs.size_ = 0;
        return *this;
    }
private:
    char* data_ = nullptr;
    size_t size_ = 0;
};
```

### 通俗易懂的理解
- 移动赋值就是“先把自己旧资源处理掉，再接管对方资源，最后把对方清空到安全状态”。

### 面试回答简版模板
`移动赋值要保证异常安全和资源唯一所有权：自赋值检查、释放旧资源、接管新资源、重置源对象，并建议 noexcept。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q08_move_assignment_operator`
