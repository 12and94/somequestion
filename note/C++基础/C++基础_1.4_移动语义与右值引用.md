# C++基础：1.4 移动语义与右值引用

本文覆盖 `面经题目分类汇总.md` 中 C++基础的 `1.4 移动语义与右值引用` 全部题目。  
每个题目统一包含：标准准确的说法、通俗易懂的理解、面试回答简版模板、对应示例。

---

## 题目：左值和右值的区别？右值引用是什么？

### 标准准确的说法
- 现代 C++（C++11+）要用“值类别（value category）”体系理解，不是只有粗粒度“左值/右值”：
  - `lvalue`：有稳定身份（identity），可持续引用的表达式（如变量名 `x`）。
  - `prvalue`：纯右值，通常是临时计算结果（如字面量 `42`、`a+b`、返回临时对象）。
  - `xvalue`：将亡值（expiring value），仍有身份但资源可被搬走（如 `std::move(x)` 的结果）。
  - 组合关系：
    - `glvalue = lvalue + xvalue`（有身份）
    - `rvalue = prvalue + xvalue`（可移动候选）
- 左值/右值的本质区别不在“能不能放等号左边”（这是旧教材口径），而在：
  - 是否有可持续身份；
  - 是否适合被“窃取资源”（移动语义）。
- 右值引用 `T&&`：
  - 是一种“绑定右值”的引用类型。
  - 典型用途：区分“可被移动”的实参，触发移动构造/移动赋值，减少深拷贝成本。
- 绑定规则（高频）：
  - `T&` 只能绑定非常量左值。
  - `const T&` 可绑定左值、右值（因此它是最通用只读接收方式）。
  - `T&&` 只能绑定右值（`prvalue/xvalue`）。
- 命名右值引用变量是左值：
  - `T&& rr = ...;` 中 `rr` 这个表达式本身是左值。
  - 若要继续按右值传递，需显式 `std::move(rr)` 转成 `xvalue`。

值类别与重载决议示例：
```cpp
#include <utility>
#include <iostream>

void f(int& )        { std::cout << "f(int&)\n"; }
void f(const int& )  { std::cout << "f(const int&)\n"; }
void f(int&& )       { std::cout << "f(int&&)\n"; }

int main() {
    int x = 1;
    const int cx = 2;

    f(x);            // 左值 -> f(int&)
    f(cx);           // const左值 -> f(const int&)
    f(3);            // prvalue -> f(int&&)
    f(std::move(x)); // xvalue  -> f(int&&)
}
```

命名右值引用为何还要 `move`：
```cpp
#include <string>
#include <utility>

std::string make();

int main() {
    std::string&& rr = make();       // rr 类型是 &&，但 rr 表达式是左值
    std::string a = rr;              // 通常走拷贝（把 rr 当左值）
    std::string b = std::move(rr);   // 显式转 xvalue，通常走移动
}
```

和转发引用的边界（避免混淆）：
```cpp
template<class T>
void g(T&& arg) { // 这里是“转发引用”，不是固定右值引用
    // arg 若接左值，T 推导为 U&，arg 实际是 U&
    // arg 若接右值，T 推导为 U ，arg 实际是 U&&
}

void h(std::string&& s) { // 这里是“普通右值引用参数”
}
```

常见误区补充：
1. `std::move` 不会移动任何字节，它只是强制类型转换为右值引用。
2. 对 `const` 对象 `std::move` 往往仍无法触发移动（得到 `const T&&`，多数移动操作需要修改源对象）。
3. “右值引用参数”与“转发引用”不是同一个概念，是否模板推导是关键。
4. 返回局部变量时滥用 `return std::move(local);` 可能干扰 NRVO，通常直接 `return local;` 更好（让编译器做返回值优化/移动）。

### 通俗易懂的理解
- 你可以把对象看成“房子 + 家具资源”：
  - 左值是“有门牌号的长期住户”，后面还可能继续住。
  - 右值是“临时住客/即将搬走的人”，可以把家具直接转给新住户，避免重新买一套（拷贝）。
- 右值引用 `T&&` 就像“搬家绿色通道”：告诉编译器这批资源可以转移。
- 但“有名字”的变量（哪怕类型是 `T&&`）都被当成长期住户看待，所以要 `std::move` 显式声明“现在可以搬了”。

### 面试回答简版模板
`现代 C++ 用 lvalue/xvalue/prvalue 描述值类别：lvalue 有稳定身份，prvalue 是纯临时值，xvalue 是将亡值；rvalue = prvalue + xvalue。右值引用 T&& 用于绑定右值并触发移动语义，但命名后的 T&& 变量本身仍是左值，继续按右值传递需 std::move。工程上要区分普通右值引用和模板中的转发引用，并避免对 const 对象误用 move。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q01_lvalue_rvalue`
- `case/cpp_basics/move_semantics_rvalue/q04_perfect_forwarding_ref_collapse`

---

## 题目：移动构造函数和拷贝构造函数的区别？

### 标准准确的说法
- 拷贝构造签名通常是 `T(const T&)`，语义是复制资源，让源和目标都保持各自可用。
- 移动构造签名通常是 `T(T&&) noexcept`，语义是转移资源所有权，让源对象变成“有效但未指定状态”。
- 对资源型对象（堆内存、文件句柄、socket）移动构造通常更高效。
- 若移动构造未声明 `noexcept`，某些容器在扩容迁移时可能回退到拷贝，影响性能。

```cpp
class Buffer {
public:
    Buffer(const Buffer& rhs);            // 深拷贝
    Buffer(Buffer&& rhs) noexcept;        // 资源转移
};
```

### 通俗易懂的理解
- 拷贝是“再买一套房”，移动是“把房产证转给你”。

### 面试回答简版模板
`拷贝构造复制资源，移动构造转移资源；对大对象或资源对象，移动显著降低开销，且建议标注 noexcept。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q02_move_vs_copy_ctor`

---

## 题目：std::move的实现原理？作用是什么？

### 标准准确的说法
- `std::move` 本质是一个无条件类型转换：把表达式转换为右值引用。
- 它不做任何资源搬迁，不会调用 `memcpy` 或系统调用。
- 真正“搬资源”的动作发生在目标类型的移动构造/移动赋值里。
- 对 `const` 对象使用 `std::move` 常无法触发移动（得到 `const T&&`，多数移动操作需要修改源对象）。

```cpp
template<class T>
constexpr std::remove_reference_t<T>&& move(T&& t) noexcept {
    return static_cast<std::remove_reference_t<T>&&>(t);
}
```

### 通俗易懂的理解
- `std::move` 只是贴标签：“这个对象你可以当成临时对象处理了”。

### 面试回答简版模板
`std::move 只做右值转换，不负责搬数据；是否真的移动取决于目标类型是否实现了高质量移动操作。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q03_std_move_principle`

---

## 题目：完美转发是什么？引用折叠规则？

### 标准准确的说法
- 完美转发目标是：在模板包装层中，把参数原本的左值/右值属性和 `const` 属性完整保留给下游。
- 典型写法：
- 形参写 `T&&`（这里是转发引用/万能引用，前提是 `T` 可推导）。
- 转发时写 `std::forward<T>(arg)`。
- 引用折叠核心规则：
- `& + & -> &`
- `& + && -> &`
- `&& + & -> &`
- `&& + && -> &&`
- 误用 `std::move(arg)` 会把左值也强制成右值，破坏语义。

```cpp
template<class T, class... Args>
std::shared_ptr<T> make_obj(Args&&... args) {
    return std::shared_ptr<T>(new T(std::forward<Args>(args)...));
}
```

### 通俗易懂的理解
- 完美转发就是“原样转交快递”，你收到的是左值就按左值交，收到的是右值就按右值交。

### 面试回答简版模板
`模板中要保留实参值类别，用转发引用配合 std::forward；引用折叠是其语义基础。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q04_perfect_forwarding_ref_collapse`

---

## 题目：什么时候需要自己写拷贝构造函数？

### 标准准确的说法
- 当类直接管理资源所有权时（裸指针、文件句柄、互斥量句柄等），默认拷贝往往不满足语义或安全性。
- 若默认拷贝会导致双重释放、共享可变状态冲突、句柄重复关闭等问题，应自定义拷贝语义。
- 若对象不可复制（例如唯一所有权），应显式 `delete` 拷贝构造和拷贝赋值。
- 工程实践优先 Rule of 0：尽量让 `std::string`、`std::vector`、智能指针等成员承担资源管理，减少手写拷贝控制。

```cpp
class UniqueFd {
public:
    UniqueFd(const UniqueFd&) = delete;
    UniqueFd& operator=(const UniqueFd&) = delete;
};
```

### 通俗易懂的理解
- 只要类里有“所有权”，就不能把默认拷贝当成理所当然。

### 面试回答简版模板
`默认拷贝语义不安全或不符合业务语义时，必须自定义或禁用拷贝；能用 Rule of 0 就尽量不手写。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q05_when_custom_copy_ctor`

---

## 题目：深拷贝和浅拷贝的区别？

### 标准准确的说法
- 浅拷贝：仅复制指针值/句柄值，多个对象共享同一底层资源。
- 深拷贝：复制资源本体，目标对象拥有独立副本。
- 对“可释放资源的所有权对象”，浅拷贝常导致双删、并发数据竞争、悬空指针等问题。
- 是否采用深拷贝取决于语义：共享语义可用 `shared_ptr`，独占语义应深拷贝或禁拷贝。

```cpp
struct Bad {
    int* p;
    Bad(const Bad& rhs) : p(rhs.p) {} // 浅拷贝，危险
};

struct Good {
    int* p;
    Good(const Good& rhs) : p(new int(*rhs.p)) {} // 深拷贝
};
```

### 通俗易懂的理解
- 浅拷贝是“复制钥匙编号”，深拷贝是“再建一把新钥匙”。

### 面试回答简版模板
`资源独占类不能做危险浅拷贝；要么深拷贝，要么禁止拷贝并改用移动或智能指针语义。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q06_deep_vs_shallow_copy`

---

## 题目：移动语义和RVO的区别？

### 标准准确的说法
- RVO/NRVO（返回值优化）是编译器优化：直接在目标存储位置构造返回对象，跳过中间临时对象。
- 移动语义是语言机制：在需要对象转移时，用移动构造/赋值替代拷贝。
- C++17 起，部分返回场景有“保证拷贝省略”，甚至不需要移动构造参与。
- 实务上三种路径并存：
- 最优：直接构造（RVO/保证省略）。
- 次优：移动。
- 最差：拷贝。

```cpp
std::string make_name() {
    std::string s = "codex";
    return s; // 可能 NRVO；否则尝试 move
}
```

### 通俗易懂的理解
- RVO 是“根本不搬家，直接在新家建好”；移动是“搬家但尽量少搬重物”。

### 面试回答简版模板
`RVO 是编译器消除中间对象，移动语义是对象间资源转移机制；优先级通常是先看是否可省略，再看能否移动。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q07_move_vs_rvo`

---

## 题目：移动赋值运算符怎么写？

### 标准准确的说法
- 典型签名：`T& operator=(T&& rhs) noexcept`。
- 必做三件事：
- 处理自赋值（`this == &rhs`）。
- 释放当前对象已有资源。
- 接管 `rhs` 资源并将 `rhs` 置为可析构状态（例如置空指针）。
- 若类管理资源，通常要与析构、拷贝构造、拷贝赋值、移动构造一起考虑（Rule of 5）。

```cpp
class Buffer {
public:
    Buffer& operator=(Buffer&& rhs) noexcept {
        if (this == &rhs) return *this;
        delete[] data_;
        data_ = rhs.data_;
        size_ = rhs.size_;
        rhs.data_ = nullptr;
        rhs.size_ = 0;
        return *this;
    }
private:
    char* data_ = nullptr;
    size_t size_ = 0;
};
```

### 通俗易懂的理解
- 移动赋值就是“先把自己旧资源处理掉，再接管对方资源，最后把对方清空到安全状态”。

### 面试回答简版模板
`移动赋值要保证异常安全和资源唯一所有权：自赋值检查、释放旧资源、接管新资源、重置源对象，并建议 noexcept。`

### 对应示例
- `case/cpp_basics/move_semantics_rvalue/q08_move_assignment_operator`
